% ---
% Capitulo de revisão de literatura
% ---
\chapter{O Paradigma Funcional}
% ---

%Menionar:

% Cálculo lambda (história)

No mesmo ano em que Alan Turing publicava sua 
tese sobre as Máquinas de Turing, Alonzo Church publicava 
a sua sobre o Cálculo Lambda. Essa abordagem da computação 
era mais embasada na matemática e foi provada como 
equivalente à Máquina de Turing pelo próprio Alan Turing. 
É nele que o paradigma funcional 
baseia-se para definir as características que serão 
melhor exploradas em seguida.


% É necessário definir melhor o que é cálculo lambda 
% aqui ou essa introdução histórica é suficiente?

% Funções puras
\section{Funções Puras}

Funções puras operam apenas nos parâmetros fornecidos. 
Elas não leem ou escrevem em qualquer valor que esteja 
fora do corpo da função.\cite{purefunctionscala} \cite{functionalscala} Por exemplo:

\begin{lstlisting}[caption={Exemplo de Função Pura},label=purefunction]

    def add(x, y) {
        return x + y;
    }

\end{lstlisting}

A função acima opera apenas nos valores x e y que 
são passados como parâmetro da função. A partir 
dessa restrição, algumas conclusões relevantes podem 
ser tiradas. Por exemplo, uma função pura sempre 
retornará o mesmo valor para os mesmos parâmetros: 
caso a função add acima receba os parâmetros 1 para x 
e 2 para y, não importa quantas vezes ela seja chamada, 
o resultado da operação sempre será 3. \cite{functionalscala}

Em seguida, um exemplo de função não pura:

\begin{lstlisting}[caption={Exemplo de Função Pura},label=purefunction]

    var z = 10;

    def modify(x, y) {
        z = x + y;
    }

\end{lstlisting}

Essa função não é pura pois ela depende de um 
valor externo - a variável z - para realizar 
uma operação. Existe ainda um outro problema 
com esse tipo de função: sua execução implica em 
um efeito colateral.

Efeitos colaterais ocorrem em consultas ou 
alterações a bases de dados, modificação de 
arquivos ou até mesmo envio de dados a um 
servidor.\cite{purefunctionscala} \cite{functionalscala} Também ocorrem quando variáveis fora 
do escopo da função são modificadas ou lidas. 
Esse tipo de comportamento é muito comum em 
paradigmas de programação imperativos ou 
orientados a objetos, porém 
podem causar dificuldades no processo de 
debug de um código, afinal, se uma variável 
pode ser alterada em qualquer lugar, um 
valor errado que ela está assumindo pode 
estar vindo de qualquer lugar.

Apesar disso, um programa precisa realizar 
efeitos colaterais, como os já citados: 
leitura e escrita em arquivos ou bancos de 
dados, requisições em servidores, exibição em 
uma tela. Por isso, a ideia no design de software 
funcional não é apenas utilizar funções puras, 
mas concentrar os efeitos colaterais em um local 
isolado das funções puras, o que facilita o 
processo de debugging.\cite{purefunctionscala}


% imutabilidade
\section{Imutabilidade}

Em programação funcional, a ideia de variáveis não 
existe, ou ao menos possui uma definição diferente. 
Em paradigmas procedurais é comum encontrarmos trechos 
de código parecidos com:

\begin{lstlisting}[caption={Exemplo de Código Mutável},label=mutablevar]

    var x = 1;
    x = x + 1;


\end{lstlisting}

Porém, esse tipo de operação não é permitida no 
paradigma funcional. Aqui é seguido o princípio 
da imutabilidade, onde uma variável \footnote{Aqui, 
variável é entendida como um valor armazenado 
e não um valor variável.} que armazena um valor 
não pode ter esse valor alterado até o fim da 
execução do programa. Dessa forma, 
o código apresentado anteriormente não seria 
possível.

Em um programa funcional, a modificação do valor 
de uma variável é feita copiando o valor para uma 
nova variável que passará a representar esse valor. 
Por exemplo, o código acima poderia ser escrito 
como:

\begin{lstlisting}[caption={Exemplo de Código Imutável},label=imutablevar]

    var x = 1;
    z = x + 1;


\end{lstlisting}

Isso pode parecer problemático quando é necessário 
modificar um único valor em uma lista ou uma estrutura 
maior e mais complexa, porém por baixo dos panos isso 
é feito de uma forma mais eficiente, sem que seja 
necessário de fato copiar toda a estrutura. Dessa forma, 
a imutabilidade está presente apenas durante a 
programação, impedindo que um valor seja alterado 
acidentalmente pelo programador ou de forma imprevista 
no caso de um programa multi-thread, por exemplo.


% Funções de alta ordem
\section{Funções de Alta Ordem}

% C# e Java já possuem suporte para HoF, mencionar aqui
Funções de alta ordem são funções que recebem 
outras funções como parâmetro e ainda podem 
retornar funções.\cite{realworldhaskell} \cite{functionalscala} Esse é um recurso 
não tão presente em linguagens orientadas a 
objeto ou procedurais, mas não é exclusivo das 
linguagens funcionais. Javascript é um bom 
exemplo de linguagem que pode receber funções 
como parâmetro em outras funções. \cite{eloquentjs}

Um bom exemplo de simplicidade do uso de 
funções de alta ordem é a função map.\cite{hofscala} Seu objetivo 
é aplicar uma função a todos os elementos de uma 
coleção e retornar a nova coleção resultante. 
Para que isso seja possível, a função map precisa 
receber como parâmetro a função que será aplicada. 
Por exemplo:

\begin{lstlisting}[caption={Exemplo de Função de Alta Ordem},label=hof]

    def add1(x){
        return x + 1;
    }

    let result = map(add1, [1, 2, 3, 4, 5]);
    // O resultado dessa operação é a lista [2, 3, 4, 5, 6]
        

\end{lstlisting}

Em uma linguagem que não aceita funções sendo 
passadas por parâmetro, uma operação simples como 
essa poderia tornar-se mais verbosa e menos legível:

\begin{lstlisting}[caption={Exemplo sem Funções de Alta Ordem},label=nohof]

    def add1(x){
        return x + 1;
    }

    let mylist = [1, 2, 3, 4, 5]
    let result = []

    foreach(n : mylist) {
        result.push(add1(n))
    }

\end{lstlisting}

Talvez a implementação da função map seja parecida 
com a função acima, porém, um programador que não 
conhece o programa levaria muito menos tempo para 
entender a primeira implementação do que a segunda. 
Além disso, para cada função diferente que poderia 
ser aplicada a essa mesma coleção, a mesma 
implementação teria que ser repetida.


\section{Closures}

Considerando a seguinte função:

\begin{lstlisting}[caption={Exemplo de Closure},label=closureex]

    def adder(x){
        return (y) => x + y;
    }

    let add10 = adder(10)

    res = add10(5)
    // O resultado acima é 15


\end{lstlisting}

Nele, definimos uma função de alta ordem, adder, que 
recebe como parâmetro um valor x e retorna uma função 
que recebe como parâmetro outro valor y e retorna a 
soma dos dois valores. A variável add10 receberá 
o retorno da chamada da função adder para o valor 10. 
Com isso, add10 será uma função que receberá como 
parâmetro um número e adicionará 10 a ele. Quando 
add10 é chamada com o valor 5 sendo passado como 
parâmetro, o retorno da função é 15.

Para que isso seja possível, a função retornada por 
adder precisou ter acesso ao valor da variável x mesmo 
após o fim da execução de adder. Isso foi possível 
por a variável x estar dentro do escopo da função 
quando ela foi criada. Esse comportamento, que torna 
o retorno de funções muito mais interessante, é chamado 
de closure. \cite{mflambdas}


% Composição de funções
\section{Composição de funções}

Reuso de código é um objetivo desejável para qualquer 
paradigma de programação, e o paradigma funcional 
proporciona uma facilidade para isso através de 
composição de funções.

O código abaixo exemplifica esse recurso:

\begin{lstlisting}[caption={Exemplo de Composição de Funções},label=fogex]

    def add1(x) {
        return x + 1
    }

    def mul2(x) {
        return x * 2
    }

    def sub4(x) {
        return x - 4
    }

    def add1ThenMul2ThenSub4(x) {
        return sub4(mul2(add1(x)))
    }

    let res = add1ThenMul2ThenSub4(1);
    // O resultado da função é 0

\end{lstlisting}

É comum qualquer linguagem permitir esse tipo 
de comportamento. Entretanto, 
utilizar funções menores e mais simples para compor 
funções maiores e mais complicadas é uma forma de 
design comum em linguagens funcionais. A diferença é 
que em linguagens funcionais as composições podem 
tornar-se mais legíveis:

\begin{lstlisting}[caption={Exemplo de Composição de Funções},label=fogex]


    let res = (add1 compose mul2 compose sub4)(1);
    // O resultado da função é 0

\end{lstlisting}


\section{Currying}

Currying é uma técnica de programação funcional que 
permite que uma função com mais de um parâmetro seja 
chamada como se possuísse apenas um. \cite{realworldhaskell} \cite{functionalscala} Por exemplo, a 
função:

\begin{lstlisting}[caption={Exemplo sem Currying},label=nocurrex]

    def add(x, y){
        return x + y;
    }

\end{lstlisting}

Poderia ser escrita da seguinte forma:

\begin{lstlisting}[caption={Exemplo de Currying},label=currex]

    def add(x){
        return y => {x + y};
    }

\end{lstlisting}

Essa técnica simplifica a composição de funções 
que possuem quantidades diferentes de parâmetros. 
Normalmente, em linguagens funcionais não é 
necessário refatorar o código como foi feito 
acima, já que as funções implementam essa técnica 
nativamente. \cite{realworldhaskell}



% mônads
\section{Mônadas}

