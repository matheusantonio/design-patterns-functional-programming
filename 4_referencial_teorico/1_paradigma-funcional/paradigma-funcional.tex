% ---
% Capitulo de revisão de literatura
% ---
\chapter{O Paradigma Funcional}
% ---

%Menionar:

% Cálculo lambda (história)

Enquanto Alan Turing definia o que 
tornaria-se a Máquina de Turing, Alonzo Church 
trabalhava em uma abordagem diferente, o Cálculo Lambda\cite{church1932set,church1936unsolvable,sep-turing-machine}. 
Apesar de parecerem muito diferentes, o primeiro baseando-se 
na modificação do estado em uma fita e o segundo 
em aplicação de funções, ambas as ideias eram 
equivalentes no que diz respeito à computação\cite{sep-church-turing}. 
O paradigma de programação funcional possui uma inspiração 
maior no cálculo lambda, o que deu origem aos conceitos 
que serão vistos a seguir.


% É necessário definir melhor o que é cálculo lambda 
% aqui ou essa introdução histórica é suficiente?



% Funções puras
\section{Funções Puras}

Funções puras operam apenas nos parâmetros fornecidos. 
Elas não leem ou escrevem em qualquer valor que esteja 
fora do corpo da função\cite{purefunctionscala, functionalscala}. Por exemplo:

\begin{lstlisting}[caption={Exemplo de Função Pura},label=purefunction]

    def add(x, y){
        return x + y;
    }

\end{lstlisting}

A função acima opera apenas nos valores x e y que 
são passados como parâmetro da função. A partir 
dessa restrição, algumas conclusões relevantes podem 
ser tiradas. Por exemplo, uma função pura sempre 
retornará o mesmo valor para os mesmos parâmetros: 
caso a função add acima receba os parâmetros 1 para x 
e 2 para y, não importa quantas vezes ela seja chamada, 
o resultado da operação sempre será 3\cite{functionalscala}.

Em seguida, um exemplo de função não pura:

\begin{lstlisting}[caption={Exemplo de Função Pura},label=purefunction]

    var z = 10;

    def modify(x, y) {
        z = x + y;
    }

\end{lstlisting}

Essa função não é pura pois ela depende de um 
valor externo - a variável z - para realizar 
uma operação. Existe ainda um outro problema 
com esse tipo de função: sua execução implica em 
um efeito colateral.

Efeitos colaterais ocorrem em consultas ou 
alterações a bases de dados, modificação de 
arquivos ou até mesmo envio de dados a um 
servidor\cite{purefunctionscala, functionalscala}. 
Também ocorrem quando variáveis fora 
do escopo da função são modificadas ou lidas. 
Esse tipo de comportamento é muito comum em 
paradigmas de programação imperativos ou 
orientados a objetos, porém 
podem causar dificuldades no processo de 
debug de um código, afinal, se uma variável 
pode ser alterada em qualquer lugar, um 
valor errado que ela está assumindo pode 
estar vindo de qualquer lugar.

Apesar disso, um programa precisa realizar 
efeitos colaterais, como os já citados: 
leitura e escrita em arquivos ou bancos de 
dados, requisições em servidores, exibição em 
uma tela. Por isso, a ideia no design de software 
funcional não é apenas utilizar funções puras, 
mas concentrar os efeitos colaterais em um local 
isolado das funções puras, o que facilita o 
processo de debugging\cite{purefunctionscala}.



% imutabilidade
\section{Imutabilidade}

Em programação funcional, a ideia de variáveis não 
existe, ou ao menos possui uma definição diferente\cite{braveclojure}.
Em paradigmas procedurais é comum encontrarmos trechos 
de código parecidos com:

\begin{lstlisting}[caption={Exemplo de Código Mutável},label=mutablevar]

    var x = 1;
    x = x + 1;


\end{lstlisting}

Porém, esse tipo de operação não é permitida no 
paradigma funcional. Aqui é seguido o princípio 
da imutabilidade, onde uma variável \footnote{Aqui, 
variável é entendida como um valor armazenado 
e não um valor variável.} que armazena um valor 
não pode ter esse valor alterado até o fim da 
execução do programa. Dessa forma, 
o código apresentado anteriormente não seria 
possível.

Em um programa funcional, a modificação do valor 
de uma variável é feita copiando o valor para uma 
nova variável que passará a representar esse valor\cite{functionalscala}.
Por exemplo, o código acima poderia ser escrito 
como:

\begin{lstlisting}[caption={Exemplo de Código Imutável},label=imutablevar]

    var x = 1;
    z = x + 1;


\end{lstlisting}

Isso pode parecer problemático quando é necessário 
modificar um único valor em uma lista ou uma estrutura 
maior e mais complexa. Porém, o compilador faz isso 
de uma forma mais eficiente, sem que seja 
necessário de fato copiar toda a estrutura\cite{functionalscala}. 
Dessa forma, a imutabilidade está presente apenas durante a 
programação, impedindo que um valor seja alterado 
acidentalmente pelo programador ou de forma imprevista 
no caso de um programa multi-thread, por exemplo.


% Composição de funções
\section{Composição de Funções}

Reuso de código é um objetivo desejável para qualquer 
paradigma de programação, e o paradigma funcional 
proporciona uma facilidade para isso através de 
composição de funções\cite{realworldhaskell}.

O código abaixo exemplifica esse recurso:

\begin{lstlisting}[caption={Exemplo de Composição de Funções},label=fogex]

    def add1(x){
        return x + 1
    }

    def mul2(x){
        return x * 2
    }

    def sub4(x){
        return x - 4
    }

    def add1ThenMul2ThenSub4(x) {
        return sub4(mul2(add1(x)))
    }

    let res = add1ThenMul2ThenSub4(1);
    // O resultado da função é 0

\end{lstlisting}

É comum qualquer linguagem permitir esse tipo 
de comportamento. Entretanto, 
utilizar funções menores e mais simples para compor 
funções maiores e mais complicadas é uma forma de 
design comum em linguagens funcionais. Uma vantagem é 
que em linguagens funcionais as composições podem 
tornar-se mais legíveis utilizando funções 
de alta ordem \footnote{Aqui, a função compose 
recebe as funções add1 e mul2 e retorna a 
composição delas. A função resultante 
é recebida como parâmetro de compose novamente, 
assim como a função sub4, resultando em uma função 
equivalente a sub4(mul2(add1()))}:

\begin{lstlisting}[caption={Exemplo de Composição de Funções},label=fogex]


    let res = (add1 compose mul2 compose sub4)(1);
    // O resultado da função é 0

\end{lstlisting}


% Funções de alta ordem
\section{Funções de Alta Ordem}

% C# e Java já possuem suporte para HoF, mencionar aqui
Funções de alta ordem são funções que recebem 
outras funções como parâmetro e ainda podem 
retornar funções\cite{realworldhaskell, functionalscala}. Esse é um recurso 
não tão comum em linguagens orientadas a 
objeto ou procedurais, mas não é exclusivo das 
linguagens funcionais. Javascript é um 
exemplo de linguagem que pode receber funções 
como parâmetro em outras funções\cite{eloquentjs}.

Um bom exemplo de simplicidade do uso de 
funções de alta ordem é a função map\cite{hofscala}. Seu objetivo 
é aplicar uma função a todos os elementos de uma 
coleção e retornar a nova coleção resultante. 
Para que isso seja possível, a função map precisa 
receber como parâmetro a função que será aplicada. 
Por exemplo:

\begin{lstlisting}[caption={Exemplo de Função de Alta Ordem},label=hof]

    def add1(x){
        return x + 1;
    }

    let result = map(add1, [1, 2, 3, 4, 5]);
    // O resultado dessa operação é a lista [2, 3, 4, 5, 6]
        

\end{lstlisting}

Em uma linguagem que não aceita funções sendo 
passadas por parâmetro, uma operação simples como 
essa poderia tornar-se mais verbosa e menos legível:

\begin{lstlisting}[caption={Exemplo sem Funções de Alta Ordem},label=nohof]

    def add1(x){
        return x + 1;
    }

    let mylist = [1, 2, 3, 4, 5]
    let result = []

    foreach(n : mylist) {
        result.push(add1(n))
    }

\end{lstlisting}

Talvez a implementação da função map seja parecida 
com a função acima, porém, um programador que não 
conhece o programa levaria muito menos tempo para 
entender a primeira implementação do que a segunda. 
Além disso, para cada função diferente que poderia 
ser aplicada a essa mesma coleção, a mesma 
implementação teria que ser repetida.




% Currying
\section{Currying}

Currying é uma técnica de programação funcional que 
permite que uma função com mais de um parâmetro seja 
chamada como se possuísse apenas um\cite{realworldhaskell, functionalscala}. 
Por exemplo, a função:

\begin{lstlisting}[caption={Exemplo sem Currying},label=nocurrex]

    def add(x, y){
        return x + y;
    }

\end{lstlisting}

Poderia ser escrita da seguinte forma:

\begin{lstlisting}[caption={Exemplo de Currying},label=currex]

    def add(x){
        return y => x + y;
    }

\end{lstlisting}

Essa técnica simplifica a composição de funções 
que possuem quantidades diferentes de parâmetros. 
Normalmente, em linguagens funcionais não é 
necessário refatorar o código como foi feito 
acima, já que as funções implementam essa técnica 
nativamente\cite{realworldhaskell}.



% Closures
\section{Closures}

Considerando a seguinte função:

\begin{lstlisting}[caption={Exemplo de Closure},label=closureex]

    def adder(x){
        return y => x + y;
    }

    let add10 = adder(10)

    res = add10(5)
    // O resultado acima é 15


\end{lstlisting}

Nele, definimos uma função de alta ordem, adder, que 
recebe como parâmetro um valor x e retorna uma função 
que recebe como parâmetro outro valor y e retorna a 
soma dos dois valores. A variável add10 receberá 
o retorno da chamada da função adder para o valor 10. 
Com isso, add10 será uma função que receberá como 
parâmetro um número e adicionará 10 a ele. Quando 
add10 é chamada com o valor 5 sendo passado como 
parâmetro, o retorno da função é 15.

Para que isso seja possível, a função retornada por 
adder precisou ter acesso ao valor da variável x mesmo 
após o fim da execução de adder. Isso foi possível 
por a variável x estar dentro do escopo da função 
quando ela foi criada. Esse comportamento, que trás 
novas possibilidades para o retorno de funções, 
é chamado de closure\cite{mflambdas}.


% mônads
\section{Mônadas}

Diferente dos conceitos anteriores, a ideia de 
mônadas 
vem da teoria das categorias \cite{functionalscala}. 
Mônadas são definidas em função de outros conceitos de 
teoria das categorias, por isso é mais simples explicá-las 
através do que elas pode fazer ao invés do que elas são. 

Diferente de um paradigma imperativo, em um programa 
funcional normalmente não possuímos a ideia de 
sequências de código, ou seja, uma sequência de 
operações seguindo uma ordem de execução. Mônadas 
trazem sequenciamento e ordem para o programa através 
de leis que definem uma estrutura parecida com as 
sentenças de um paradigma imperativo\cite{camargomonads}.
É possível observar esse comportamento nos \textit{for 
comprehensions} da linguagem Scala\cite{functionalscala}:

\begin{lstlisting}[caption={Exemplo de notação for},label=foropscala]

    for {
        y <- f(x)
        z <- g(y)
    } yield z
    

\end{lstlisting}

Nesse código, a operação f precisa ser executada 
antes da operação g, já que ela depende de seu 
resultado. É possível observar que esse é um caso 
simples de composição de funções, e de fato os 
\textit{for comprehensions} são apenas \textit{syntatic 
sugar}\footnote{\textit{syntatic sugar} são sintaxes 
definidas em linguagens de programação com a intenção 
de facilitar a leitura ou expressividade do código.} 
para o encadeamento de operações monádicas\cite{yieldscala}. 
Ou seja, o código acima poderia ser escrito 
da seguinte forma:

\begin{lstlisting}[caption={Exemplo de fmap},label=fmapscala]

    flatMap()
    

\end{lstlisting}