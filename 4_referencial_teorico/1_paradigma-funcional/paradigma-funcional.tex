% ---
% Capitulo de revisão de literatura
% ---
\chapter{O Paradigma Funcional}
% ---

Originado no cálculo lambda, o paradigma funcional 
apresenta uma forma diferente de desenvolver quando 
comparado à programação imperativa ou orientada a 
objetos. A seguir, serão vistos os principais 
conceitos de programação funcional que serão 
levados em consideração durante a análise dos 
padrões de projeto.

% Funções puras
\section{Funções Puras}

Funções puras operam apenas nos parâmetros fornecidos. 
Elas não leem ou escrevem em qualquer valor que esteja 
fora do corpo da função\cite{purefunctionscala, functionalscala}.

\begin{lstlisting}[caption={Exemplo de Função Pura},label=purefunction]

    def add(x, y){
        return x + y;
    }

\end{lstlisting}

A função apresentada no código \ref{purefunction} 
opera apenas nos valores x e y que 
são passados como parâmetro da função. A partir 
dessa restrição, algumas conclusões relevantes podem 
ser tiradas. Por exemplo, uma função pura sempre 
retornará o mesmo valor para os mesmos parâmetros: 
caso a função add vista receba os parâmetros 1 para x 
e 2 para y, não importa quantas vezes ela seja chamada, 
o resultado da operação sempre será 3\cite{functionalscala}.

\begin{lstlisting}[caption={Exemplo de Função Pura},label=impurefunction]

    var z = 10;

    def modify(x, y) {
        z = x + y;
    }

\end{lstlisting}

O código \ref{impurefunction} apresenta uma função 
não pura, modify. Essa função não é pura pois 
depende de um valor externo - a variável z - para 
realizar uma operação. Existe ainda um outro problema 
com esse tipo de função: sua execução implica em 
um efeito colateral.

Efeitos colaterais ocorrem em consultas ou 
alterações a bases de dados, modificação de 
arquivos ou até mesmo envio de dados a um 
servidor\cite{purefunctionscala, functionalscala}. 
Também ocorrem quando variáveis fora 
do escopo da função são modificadas ou lidas. 
Esse tipo de comportamento é muito comum em 
paradigmas de programação imperativos ou 
orientados a objetos, porém 
podem causar dificuldades no processo de 
\textit{debug} de um código, afinal, 
quanto maior for a quantidade de locais onde 
uma variávei pode ser modificada, maior 
será o esforço para encontrar a origem de 
um problema relacionado ao valor que essa 
variável pode assumir.

Apesar disso, um programa precisa realizar 
efeitos colaterais, como os já citados: 
leitura e escrita em arquivos ou bancos de 
dados, requisições em servidores, exibição em 
uma tela. Por isso, a ideia no \textit{design} de 
\textit{software} funcional não é apenas utilizar 
funções puras, mas concentrar esses efeitos 
colaterais necessários em um local isolado das 
funções puras, o que facilita o 
processo de \textit{debugging}\cite{purefunctionscala}.



% imutabilidade
\section{Imutabilidade}

Em programação funcional, a ideia de variáveis não 
existe, ou ao menos possui uma definição diferente\cite{braveclojure}.
Em paradigmas procedurais é comum encontar trechos 
de código parecidos com o apresentado no código \ref{mutablevar}.

\begin{lstlisting}[caption={Exemplo de Código Mutável},label=mutablevar]

    var x = 1;
    x = x + 1;


\end{lstlisting}

Porém, esse tipo de operação não é permitida no 
paradigma funcional, já que ele segue o princípio 
da imutabilidade, onde uma variável \footnote{Aqui, 
variável é entendida como um valor armazenado 
e não um valor variável.} que armazena um valor 
não pode ter esse valor alterado até o fim da 
execução do programa. Esse princípio é violado  
pelo código \ref{mutablevar}.

Em um programa funcional, a modificação do valor 
de uma variável é feita copiando o valor para uma 
nova variável que passará a representar esse valor\cite{functionalscala}.
Por exemplo, o código \textit{mutablevar} poderia ser 
escrito como no código \ref{imutablevar}.

\begin{lstlisting}[caption={Exemplo de Código Imutável},label=imutablevar]

    var x = 1;
    z = x + 1;


\end{lstlisting}

Apesar de parecer problemático quando é necessário 
modificar um único valor em uma lista ou uma estrutura 
de dados maior e mais complexa, o compilador torna o 
processo de cópia mais eficiente, sem que seja 
necessário de fato copiar toda a estrutura\cite{functionalscala}. 
Dessa forma, a imutabilidade impede que um valor 
atribuído seja alterado apenas durante a 
programação.


% Funções de alta ordem
\section{Funções de Alta Ordem}

% C# e Java já possuem suporte para HoF, mencionar aqui
Funções de alta ordem são funções que recebem 
outras funções como parâmetro e ainda podem 
retornar funções\cite{realworldhaskell, functionalscala}. 
Esse é um recurso 
não tão comum em linguagens orientadas a 
objeto ou procedurais, mas não é exclusivo das 
linguagens funcionais. Javascript\cite{eloquentjs}, 
Python\cite{denerocomposing} e C\#\cite{buonannofunctcsharp}
são alguns exemplos de linguagens que possuem suporte 
para funções de alta ordem.

Um bom exemplo de simplicidade do uso de 
funções de alta ordem é a função map\cite{hofscala}. Seu objetivo 
é aplicar uma função a todos os elementos de uma 
coleção e retornar a nova coleção resultante. 
Para que isso seja possível, a função map precisa 
receber como parâmetro a função que será aplicada. 
O código \ref{hof} demonstra o uso dessa função.

\begin{lstlisting}[caption={Exemplo de Função de Alta Ordem},label=hof]

    def add1(x){
        return x + 1;
    }

    let result = map(add1, [1, 2, 3, 4, 5]);
    // O resultado dessa operação é a lista [2, 3, 4, 5, 6]
        

\end{lstlisting}

Em uma linguagem que não aceita funções sendo 
passadas por parâmetro, uma operação simples como 
essa poderia se tornar mais verbosa e menos legível, 
como no código \ref{nohof}.

\begin{lstlisting}[caption={Exemplo sem Funções de Alta Ordem},label=nohof]

    def add1(x){
        return x + 1;
    }

    let mylist = [1, 2, 3, 4, 5]
    let result = []

    foreach(n : mylist) {
        result.push(add1(n))
    }

\end{lstlisting}

\begin{comment}
Talvez a implementação da função map seja parecida 
com a função acima, porém, um programador que não 
conhece o programa levaria muito menos tempo para 
entender a primeira implementação do que a segunda. 
Além disso, para cada função diferente que poderia 
ser aplicada a essa mesma coleção, a mesma 
implementação teria que ser repetida.
\end{comment}



% Currying
\section{Currying}

Currying é uma técnica de programação funcional que 
permite que uma função com mais de um parâmetro seja 
chamada como se possuísse apenas um\cite{realworldhaskell, functionalscala}. 
Por exemplo, a função add apresentada no código 
\ref{nocurrex} poderia ser escrita como no código 
\ref{currex}.

\begin{lstlisting}[caption={Exemplo sem Currying},label=nocurrex]

    def add(x, y){
        return x + y;
    }

\end{lstlisting}

\begin{lstlisting}[caption={Exemplo de Currying},label=currex]

    def add(x){
        return y => x + y;
    }

\end{lstlisting}

Essa técnica simplifica a composição de funções 
que possuem quantidades diferentes de parâmetros. 
Em algumas linguagens funcionais não é 
necessário refatorar o código como foi feito 
acima, já que as funções implementam essa técnica 
nativamente\cite{realworldhaskell}.



% Closures
\section{Closures}

No código \ref{closureex} é definida a função adder que 
recebe como parâmetro um valor x e retorna uma função 
que recebe como parâmetro outro valor y, retornando a 
soma dos dois valores. A variável add10 receberá 
o retorno da chamada da função adder para o valor 10. 
Com isso, add10 será uma função que receberá como 
parâmetro um número e adicionará 10 a ele. Quando 
add10 é chamada com o valor 5 sendo passado como 
parâmetro, o retorno da função é 15.

\begin{lstlisting}[caption={Exemplo de Closure},label=closureex]

    def adder(x){
        return y => x + y;
    }

    let add10 = adder(10)

    res = add10(5)
    // O resultado acima é 15


\end{lstlisting}

Para que isso seja possível, a função retornada por 
adder precisou ter acesso ao valor da variável x mesmo 
após o fim da execução de adder. Isso foi possível 
por a variável x estar dentro do escopo da função 
quando ela foi criada. Esse comportamento, 
possível através do retorno de funções, 
é chamado de closure\cite{mflambdas}.


% Composição de funções
\section{Composição de Funções}

Reuso de código é um objetivo desejável para qualquer 
paradigma de programação, e o paradigma funcional 
aproveita a composição de funções para seguir esse 
princípio\cite{realworldhaskell}.
O código \ref{fogex} exemplifica esse recurso.

\begin{lstlisting}[caption={Exemplo de Composição de Funções},label=fogex]

    def add1(x){
        return x + 1
    }

    def mul2(x){
        return x * 2
    }

    def sub4(x){
        return x - 4
    }

    def add1ThenMul2ThenSub4(x) {
        return sub4(mul2(add1(x)))
    }

    let res = add1ThenMul2ThenSub4(1);
    // O resultado da função é 0

\end{lstlisting}

É comum qualquer linguagem permitir esse tipo 
de comportamento. Entretanto, 
utilizar funções menores e mais simples para compor 
funções maiores e mais complicadas é uma forma de 
\textit{design} comum em linguagens funcionais. Uma vantagem é 
que em linguagens funcionais as composições podem 
tornar-se mais legíveis utilizando funções 
de alta ordem, como pode ser visto no código 
\ref{hofogex} \footnote{Aqui, a função compose 
recebe as funções add1 e mul2 e retorna a 
composição delas. A função resultante 
é recebida como parâmetro de compose novamente, 
assim como a função sub4, resultando em uma função 
equivalente a sub4(mul2(add1()))}.

\begin{lstlisting}[caption={Exemplo de Composição de Funções},label=hofogex]


    let res = (sub4 compose mul2 compose add1)(1);
    // O resultado da função é 0

\end{lstlisting}
