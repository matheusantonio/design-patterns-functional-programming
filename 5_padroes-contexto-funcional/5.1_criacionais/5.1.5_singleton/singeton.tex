\section{Singleton}

O padrão Singleton garante que um objeto possuirá apenas uma 
instância. Além disso, fornece um único ponto, acessível 
globalmente, a essa instância. Essa implementação é útil 
para implementar classes que fornecem serviços sem que seja 
necessário instanciar vários objetos idênticos em 
locais diferentes do código.

A figura \ref{singleton_struct} demonstra a implementação 
do padrão. A classe Singleton possui um método construtor 
privado e armazena no atributo estático uniqueInstance uma 
instância de Singleton. Através do método de classe 
Instance, é verificado se já existe uma instância 
armazenada no atributo uniqueInstance. Caso já exista, 
ela é retornada. Caso não, a instância única é criada 
para ser retornada nas chamadas posteriores de Instance.

\begin{figure}[htb]
	\caption{\label{singleton_struct}Estrutura do Singleton}
	\begin{center}
	    \includegraphics[scale=0.6]{5_padroes-contexto-funcional/5.1_criacionais/5.1.5_singleton/singleton_estrutura.png}
	\end{center}
\end{figure}

\subsection*{Exemplo Orientado a Objetos}

Uma classe define as operações para realizar transações com 
uma base de dados. Como a instância dela é idêntica independente 
do cliente que a utiliza, não existe a necessidade de replicar 
essas instâncias pelo código. Ela pode ser transformada em 
um Singleton, o que faz com que toda classe que deseja fazer 
uma transação na base de dados apenas solicite uma instância 
e realize as operações. A definição da classe do exemplo 
pode ser vista na figura \ref{singleton_exemplo} e no 
código \ref{oosingleton}.

\begin{figure}[htb]
	\caption{\label{singleton_exemplo}Exemplo de Singleton}
	\begin{center}
	    \includegraphics[scale=0.6]{5_padroes-contexto-funcional/5.1_criacionais/5.1.5_singleton/singleton_exemplo.png}
	\end{center}
\end{figure}

\begin{lstlisting}[caption={Singleton Orientação a Objetos},label=oosingleton]

class Database private(){
  def Query(sql : String) : Object = {
    //Execute query
    null
  }
  def Command(sql : String) : Unit = {
    //Execute command
  }
}

object Database {
  private var instance : Database = null

  def Instance() : Database = {
    if(instance == null){
      instance = new Database()
    }
    instance
  }
}

\end{lstlisting}

\subsection*{Contexto Funcional}

\begin{comment}

Não existe uma forma de implementar o Singleton no contexto funcional 
por que ele viola o conceito de função pura, ou seja, a função não 
está mais dependendo apenas de seus parâmetros, mas também de um 
valor global que ainda pode ter seu estado modificado.

Porém, ainda existem formas de alcançar seu objetivo, ou seja, 
oferecer acesso a um serviço em diversos locais do código sem a necessidade 
de repeti-lo. A primeira forma é usando um conceito que não é exlusivamente funcional, 
já que até no contexto orientdo a objetos é considerado um bom substituto 
para o Singleton. Porém, por ser uma abordagem também utilizada por 
programas que seguem o paradigma funcional e consequentemente por não 
violar o paradigma, será mencionado como uma possível solução.

A abordagem consiste no uso da Injeção de Dependência, onde a criação de 
recurso utilizado por uma função ou objeto não é responsabilidade da mesma, 
ao invés disso, esse recurso é injetado, seja pelo construtor (no caso da 
orientação a objetos) ou por parâmetros de uma função (no caso do paradigma 
funcional).

\begin{lstlisting}[caption={Injeção de Dependência funcional},label=fpdi]
    
    

\end{lstlisting}

A segunda abordagem consiste na utilização de um Monad conhecido como 
Reader. As funções que precisam utilizar um determinado serviço são 
encapsuladas em um Monad. O estado desse serviço será acessável dentro 
dessas funções e sempre que suas execuções terminarem, o novo estado 
do serviço será retornado. Dessa forma, a próxima função que deseja 
utilizar o serviço poderá usufruir do estado atualizado.

\begin{lstlisting}[caption={Monad Reader},label=fpreader]
    
    

\end{lstlisting}

Essa abordagem tem algumas vantagens se comparada à injeção de dependência: 
Suponha que três funções são encadeadas em um programa. A primeira e a terceira 
precisarão utilizar o serviço que é injetado através dos parâmetros. A segunda 
função, mesmo sem utilizar o serviço, precisará recebê-lo em seus parâmetros 
para que ele seja passado para a terceira função. Isso diminui a reusabilidade 
dessa função, que poderia ser reaproveitada em um contexto onde o serviço não 
é necessário. Também há a poluição visual ao incluir, em diversas funções, 
parâmetros diferentes para fornecer os serviços. Em casos em que mais de um serviço 
é utilizado, a situação torna-se ainda mais caótica.

\end{comment}