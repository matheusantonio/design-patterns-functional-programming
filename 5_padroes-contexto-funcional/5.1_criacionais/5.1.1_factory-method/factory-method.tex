\chapter{Padrões Criacionais}

\section{Factory Method}

O Factory Method define uma interface para criar 
objetos de forma que a responsabilidade de criação 
desses objetos seja da classe que irá implementá-la. 
Assim, a interface não precisa saber qual 
classe deve ser instanciada, permitindo que versões 
diferentes ou implementações específicas de um mesmo 
tipo de objeto possam ser criadas.

Na figura \ref{fmethod_struct} é demonstrada 
a estrutura do padrão, onde a classe abstrata Creator 
define a operação abstrata que cria o objeto, 
o \textit{factory method}. A classe ConcreteCreator 
implementa a operação FactoryMethod, criando um objeto 
do tipo ConcreteProduct, que é uma implementação 
específica de um tipo Product. Dessa forma, a classe 
abstrata Creator não precisa saber qual implementação 
de Product será criada.

\begin{figure}[htb]
	\caption{\label{fmethod_struct}Estrutura do Factory Method}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.1_criacionais/5.1.1_factory-method/factorymethod_struct.png}
	\end{center}
\end{figure}


\subsection*{Exemplo Orientado a Objetos}

Como exemplo é apresentado um \textit{framework} 
que cria e apresenta para o usuário múltiplos 
documentos. Para isso, a classe abstrata 
Application é definida com a operação abstrata 
CreateDocument e com uma lista de objetos 
que implementam a interface Document. A classe 
concreta MyDocument implementa Document e define 
um tipo de documento que pode ser utilizado pelo 
\textit{framework}, enquanto a classe concreta 
MyApplication herda de Application e implementa 
a operação CreateDocument para que ela crie 
um objeto do tipo MyDocument. O diagrama de classes 
para o exemplo pode ser visto na figura \ref{fmethod_example}, 
enquanto a implementação pode ser vista no 
código \ref{oofactory}.


\begin{figure}[htb]
	\caption{\label{fmethod_example}Exemplo de Factory Method}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.1_criacionais/5.1.1_factory-method/factorymethod_exemplo.png}
	\end{center}
\end{figure}

\begin{lstlisting}[caption={Factory Method Orientado a Objetos},label=oofactory]
    
abstract class Document {
  def Open()
  def Close()
  def Save()
  def Revert()
}

abstract class Application {
  var documents : List[Document] = List()

  def CreateDocument() : Document

  def NewDocument() : Unit = {
    val doc = CreateDocument()
    this.documents = doc :: this.documents
    doc.Open()
  }

  def OpenDocument(): Unit = {
    // Abre um documento
  }
}

class MyApplication extends Application {
  def CreateDocument(): Document = new MyDocument()
}

class MyDocument extends Document {
  def Open(): Unit ={
    //...
  }

  def Close(): Unit ={
    //...
  }

  def Save(): Unit ={
    //...
  }

  def Revert(): Unit ={
    //...
  }
}

\end{lstlisting}

\subsection*{Contexto Funcional}

As funções de alta ordem tornam desnecessária 
a criação de uma especialização da classe 
Application vista no exemplo orientado a 
objetos. Ao invés de criar uma nova classe 
apenas para definir o tipo de documento 
que será instanciado, basta que 
uma função da aplicação receba como parâmetro 
a função responsável pela criação do documento. 
Assim, qualquer função que crie um documento 
pode ser usada. 

O código \ref{fpfactory} demonstra a definição 
do tipo Document na linha 2, além da função 
que cria um tipo específico de documento na 
linha 4. Uma função qualquer da aplicação, 
como a função ApplicationFunction 
definida na linha 8, recebe como parâmetro 
uma função que retorna um documento. Por 
fim, na linha 14 pode ser vista a chamada 
da função ApplicationFunction recebendo a 
função de criação CreateMyDocument.

\begin{lstlisting}[caption={Factory Method Funcional},label=fpfactory]
    
type Document

def CreateMyDocument() : Document = {
  // Cria o documento específico para o framework
}

def ApplicationFunction(createDocument : () => Document): Unit = {
  // ...
  val docuemnt = createDocument()
  // ...
}

ApplicationFunction(CreateMyDocument)

\end{lstlisting}

