\section{Prototype}

O padrão Prototype permite reduzir a quantidade 
de subclasses definidas em uma aplicação 
substituindo-as por instâncias predefinidas 
que podem ser reutilizadas em tempo de 
execução. Objetos que funcionam como 
protótipos podem ser clonados e assim 
reutilizados por outros objetos, sendo uma 
alternativa à herança. 

A estrutura do padrão, apresentada na imagem 
\ref{prototype_struct}, mostra uma interface 
Prototype que define a operação Clone, responsável 
por copiar o protótipo reutilizável de um objeto. 
As classes ConcretePrototype implementam essa 
interface e a operação que retorna essa cópia. 
A classe Client acessa o protótipo através da operação 
Clone. Essa dinâmica permite que a classe cliente 
não precise conhecer o objeto clonado nem sua 
implementação, o que as torna independentes e 
diminui o acoplamento.

\begin{figure}[htb]
	\caption{\label{prototype_struct}Estrutura do Prototype}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.1_criacionais/5.1.4_prototype/prototype_estrutura.png}
	\end{center}
\end{figure}


\subsection*{Exemplo Orientado a Objetos}

Como exemplo de uso do Prototype, um 
\textit{framework} de editores gráficos deseja 
ser utilizado para construir um editor de 
partituras musicais. A classe responsável pelo 
desenho de elemntos gráficos na tela não 
conhece as classes de notas musicais que 
precisam ser desenhadas. Ao invés de criar uma 
subclasse para cada novo elemento gráfico, 
a classe responsável pelo desenho 
pode ser implementada de forma que receba 
um objeto protótipo que não precisa ser 
conhecido. Dessa forma, trocando a herança 
por uma delegação, é possível desenhar qualquer 
elemento musical, desde que ele possa ser 
clonado. A figura \ref{prototype_exemplo} e 
o código \ref{ooprototype} ilustram esse cenário.

\begin{figure}[htb]
	\caption{\label{prototype_exemplo}Exemplo de Prototype}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.1_criacionais/5.1.4_prototype/prototype_exemplo.png}
	\end{center}
\end{figure}

\begin{lstlisting}[caption={Prototype Orientado a Objetos},label=ooprototype]

trait Graphic {
  def Draw(position : Position)
  def Clone() : Graphic
}

class Staff extends Graphic {
  def Draw(position : Position) :Unit = {
    println("Desenha elemento")
  }

  def Clone() : Graphic = this.Clone()
}

trait MusicalNote extends Graphic

class WholeNote extends MusicalNote {
  def Draw(position : Position) : Unit = {
    println("Desenha nota musical")
  }

  def Clone() : Graphic = this.Clone()
}

class HalfNote extends MusicalNote {
  def Draw(position: Position): Unit = {
    println("Desenha nota musical")
  }

  def Clone() : Graphic = this.Clone()
}

class GraphicTool(var prototype : Graphic) {

  def Manipulate() : Unit = {
    var p = this.prototype.Clone()
    while(User.DragsMouse()) {
      p.Draw(newPosition)
    }
    //...
  }
}

\end{lstlisting}

\subsection*{Contexto Funcional}



\begin{lstlisting}[caption={Prototype Funcional},label=fpprototype]
    
def GeneratePrototype(graphic : Graphic): () => Graphic =
  () => graphic 

def ManipulateGraphic(Clone : () => Graphic) = {
  val p = Clone()
  while(dragsMouse){
    Draw(p, newPosition)
  }
}
    
\end{lstlisting}