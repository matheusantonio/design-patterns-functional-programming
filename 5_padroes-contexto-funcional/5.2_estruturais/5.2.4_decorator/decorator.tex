\section{Decorator}

O padrão Decorator permite adicionar responsabilidades a um 
objeto de forma dinâmica. Essa dinamicidade é alcançada 
substituindo a herança por uma delegação, fazendo com 
que a classe decorada delegue à classe que a estende 
a nova responsabilidade.

Para que o processo seja transparente, tanto as 
as classes de extensão quanto a classe decorada 
implementam uma interface em comum. As classes 
de extensão podem também ser decoradas por 
novas classes de extensão, permitindo adicionar 
diversas responsabilidades para a classe decorada, 
formando uma estrutura de pilha onde o elemento ao 
fundo é o objeto decorado. Ele será o 
alvo das operações acumuladas de todos os extensores 
presentes na estrutura. O diagrama de classes que 
demonstra essa estrutura pode ser visto na figura 
\ref{decorator_struct}.

O maior problema resolvido pelo Decorator é a grande 
quantidade de subclasses que deveriam existir caso houvessem 
muitas extensões para uma classe. O problema cresce ainda 
mais quando é necessário que essas funcionalidades mudem 
dinamicamente, gerando diversas combinações de grupos de 
funcionalidades possíveis.

\begin{figure}[htb]
	\caption{\label{decorator_struct}Estrutura do Decorator}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.2_estruturais/5.2.4_decorator/decorator_estrutura.png}
	\end{center}
\end{figure}

\subsection*{Exemplo Orientado a Objetos}

Como exemplo, é apresentado uma ferramenta  
gráfica que permite que diversas funcionalidades, 
como bordas ou barras de rolagem, possam ser adicionadas 
a qualquer componente. Ao invés de usar herança, 
o que exigiria que houvesse uma subclasse para cada 
combinação de funcionalidades e elementos gráficos, 
o padrão Decorator é utilizado. Por exemplo, um 
elemento de texto pode ser decorado com uma barra 
de rolagem ou com uma borda. A figura \ref{decorator_exemplo} 
demonstra o diagrama de classes para esse caso, 
onde uma classe TextView implementa uma interface 
VisualComponent, assim como a classe abstrata Decorator, 
que armazena em seus atributos um objeto do tipo 
VisualComponent. As classes ScrollDecorator e 
BorderDecorator herdam de Decorator, o que faz com que 
elas implementem VisualComponent. Uma das 
possibilidades desse cenário é que um objeto do tipo 
ScrollDecorator armazene um BorderDecorator, que 
por sua vez armazenará um TextView. A operação 
Draw será chamada, em sequência, para cada 
elemento da pilha, resultando no TextView 
com as funcionalidades desejadas. O código 
\ref{oodecorator} traz a implementação dessa 
abordagem.

\begin{figure}[htb]
	\caption{\label{decorator_exemplo}Exemplo de Decorator}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.2_estruturais/5.2.4_decorator/decorator_exemplo.png}
	\end{center}
\end{figure}

\begin{lstlisting}[caption={Decorator Orientado a Objetos},label=oodecorator]

trait VisualComponent {
  def Draw()
}

class TextView extends VisualComponent {
  def Draw(): Unit = {
    //Desenha o componente
  }
}

abstract class Decorator(val component : VisualComponent) extends VisualComponent {
  override def Draw(): Unit = {
    component.Draw()
  }
}

class ScrollDecorator(visualComponent: VisualComponent)
  extends Decorator(visualComponent) {

  var ScrollPosition : Int = 0

  override def Draw() : Unit = {
    //Desenha Scroll
    super.Draw()
  }
}

class BorderDecorator(visualComponent: VisualComponent)
  extends Decorator(visualComponent){

  var BorderWidth : Int = 0

  override def Draw(): Unit = {
    //Desenha Border
    super.Draw()
  }
}

\end{lstlisting}

\subsection*{Contexto Funcional}

Para que o Decorator possa ser usado no contexto 
funcional para estender operações, as funções 
decoradoras devem receber como parâmetro uma função 
que possua a mesma assinatura da função decorada. 
Elas também devem retornar uma função que receba 
como parâmetro os valores de entrada para a 
função decorada. Internamente, as funções decoradoras 
chamam a função recebida como parâmetro e realizam 
qualquer operação adicional necessária. 

Com essa implementação, a função resultante de uma 
função decoradora possui a mesma assinatura da função 
decorada, fazendo com que a aplicação não precise adaptar 
os parâmetros ao utilizá-la. Isso também permite 
encadear as funções decoradoras, trazendo uma estrutura de 
pilha, semelhante à implementação orientada a objetos.

O código \ref{fpdecorator} demonstra o exemplo anterior, onde 
a função DrawTextView, na linha 2, recebe como parâmetro uma 
String e cria um \textit{text view} que a exibe. As funções 
DrawTextScroll, na linha 4, e DrawBorder, na linha 11, decoram 
a função DrawTextView, exibindo também uma barra de \textit{scroll} 
e bordas para o componente. Por fim, o valor DecoratedDraw, na 
linha 18, encadeia as três funções, criando uma nova função 
com a mesma assinatura de DrawTextView com as funcionalidades 
adicionais.

\begin{lstlisting}[caption={Decorator Funcional},label=fpdecorator]
    
def DrawTextView(text : String) : Unit = println(text)

def DrawTextScroll(position : Int, Draw : (String) => Unit) : (String) => Unit = {
  (text : String) => {
    println("Scroll at " + position)
    Draw(text)
  }
}

def DrawBorder(width : Int, Draw : (String) => Unit) : (String) => Unit = {
  (text : String) => {
  println("Border of width " + width)
  Draw(text)
  }
}

val DecoratedDraw : (String) => Unit =
  DrawBorder(3,
    DrawTextScroll(5,
      Draw))
    
\end{lstlisting}