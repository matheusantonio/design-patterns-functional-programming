\section{Mediator}


Nesse padrão, um objeto chamado de Mediator age como intermediário 
entre um grupo de objetos, ficando responsável por qualquer 
interação entre eles. O Mediator conhece todos 
esses objetos enquanto cada objeto conhece apenas o 
Mediator, o que os torna 
mais independentes, simplificando sua reutilização
 e concentrando as dependências entre eles 
em um só lugar. 

A estrutura do padrão é apresentada na figura \ref{mediator_struct}. 
Uma interface Mediator define as operações que um tipo de 
objeto Mediator deve possuir. ConcreteMediator representa 
uma classe que implementa essas operações. Um Colleague 
é um objeto conhecido pelo Mediator e cada ConcreteColleague 
pode ser tanto um objeto que possui operações refletidas 
em outros objetos quanto ser um dos objetos afetados 
indiretamente por outro Colleague.

\begin{figure}[htb]
	\caption{\label{mediator_struct}Estrutura do Mediator}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.3_comportamentais/5.3.05_mediator/mediator_estrutura.png}
	\end{center}
\end{figure}

\subsection*{Exemplo Orientado a Objetos}

Como exemplo, é considerada uma janela de uma aplicação 
que apresenta diversos \textit{widgets}, entre eles uma caixa 
de entrada de texto e uma lista de seleção. Quando um item é 
selecionado na lista, o texto contido nele deve aparecer 
na caixa de entrada de texto. O Mediator é responsável 
por alterar a caixa de entrada de texto quando um item 
é selecionado na lista, enquanto a lista é responsável 
por informar ao Mediator quando um item for selecionado. 
A figura \ref{mediator_exemplo} apresenta o diagrama 
de classes para esse exemplo. O código \ref{oomediator} 
apresenta a implementação do padrão para esse exemplo.

\begin{figure}[htb]
	\caption{\label{mediator_exemplo}Exemplo de Mediator}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.3_comportamentais/5.3.05_mediator/mediator_exemplo.png}
	\end{center}
\end{figure}

\begin{lstlisting}[caption={Mediator Orientado a Objetos},label=oomediator]

abstract class DialogDirector {

  def ShowDialog() : Unit = {
    //Exibe o dialog
  }

  def CreateWidget()
  def WidgetChanged(widget: Widget)
}

class FontDialogDirector() extends DialogDirector {

  private var list : ListBox = null
  private var field : EntryField = null

  override def CreateWidget(): Unit = {
    this.list = new ListBox(this)
    this.field = new EntryField(this)
  }

  override def WidgetChanged(widget: Widget): Unit = {
    this.field.text = this.list.selection
  }
}

abstract class Widget(val director : DialogDirector) {
  def Changed() : Unit = director.WidgetChanged(this)
}

class EntryField(director : DialogDirector) extends Widget(director) {
  var text : String = ""
}

class ListBox(director : DialogDirector) extends Widget(director){
  private var _selection : String = ""
  def selection : String = _selection

  def SetSelection(selection : String) : Unit = {
    this._selection = selection
    Changed()
  }
}
    
\end{lstlisting}

\subsection*{Contexto Funcional}

O código \ref{fpmediator} demonstra a implementação 
funcional do Mediator. Uma função é responsável por 
gerenciar as interdependências entre os valores 
dos tipos EntryField, definido na linha 2, e ListBox, 
definido na linha 12. Quando a função mediadora ChangeSelection, 
definida na linha 22, é chamada, ela precisa receber 
como parâmetro o elemento alvo e o elemento dependente, 
além das informações necessárias para executar a 
operação ChangeListBoxSelection. A função retorna 
tanto o \textit{colleague} alvo da operação 
quanto os \textit{colleagues} afetados, mantendo 
a função cliente que chama essa operação atualizada 
quanto ao estado de ambos os valores. 

A vantagem dessa abordagem é que ela torna possível 
que as funções dos \textit{colleagues} (no código 
\ref{fpmediator}, ChangeEntryFieldText e 
ChangeListBoxSelection) sejam idependentes dos 
mediadodores, favorecendo seu reuso. A desvantagem 
é que é necessário realizar, na função cliente, 
um gerenciamento quanto ao estado de todos os 
\textit{colleagues}, já que a função mediadora 
deve ser pura e não realiza efeitos colaterais.

\begin{lstlisting}[caption={Mediator Funcional},label=fpmediator]
    
type EntryField = String

def ChangeEntryFieldText(text : String,
						 entryField: EntryField)
: EntryField =
  text
  
def GetText(entryField : EntryField) : String =
  entryField
  
type ListBox = String
  
def ChangeListBoxSelection(selection : String,
						   listBox: ListBox)
: ListBox =
  selection
  
def GetSelection(listBox : ListBox)  : String=
  listBox
  
def ChangeSelection(selection : String,
					entryField: EntryField,
					listBox : ListBox) : (EntryField, ListBox) = {
  (ChangeListBoxSelection(selection, listBox), ChangeEntryFieldText(selection, entryField))
}
	    
\end{lstlisting}