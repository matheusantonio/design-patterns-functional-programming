\section{State}

O padrão State permite alterar o comportamento de um objeto 
alterando seu estado interno. As operações que dependem do 
estado do objeto são definidas em uma interface conhecida 
pelo objeto, de forma que ele delegue essas operações 
para outra classe que implemente essa interface. 

Essa abordagem contribui para o reuso de operações 
que se repetem em classes relacionadas. Sem o State, 
essas classes teriam que ser instanciadas novamente 
a cada mudança de estado. Outra vantagem é que o 
padrão permite que o estado seja trocado dinamicamente 
durante a execução. A estrutura do padrão pode ser 
vista na figura \ref{state_struct}.

\begin{figure}[htb]
	\caption{\label{state_struct}Estrutura do State}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.3_comportamentais/5.3.08_state/state_estrutura.png}
	\end{center}
\end{figure}

\subsection*{Exemplo Orientado a Objetos}

Como exemplo, é considerada uma classe TCPConnection 
que define uma conexão de rede que pode estar em diversos 
estados: Estabelecida, escutando e fechada. Dependendo 
do estado em que a conexão se encontra, ela deve 
responder de forma diferente às operações que uma 
conexão TCP pode realizar. O padrão Strategy, cuja 
implementação pode ser vista no diagrama da imagem 
\ref{state_exemplo} e no código \ref{oostate}, é 
utilizado para encapsular em classes diferentes as 
operações referentes a cada estado da conexão. 
Dessa forma, a classe TCPConnection delega a uma classe 
que implementa a interface TCPState a execução das 
operações necessárias. Quando o estado interno da classe 
for modificado, a operação referente ao novo estado 
também será alterada automaticamente.

\begin{figure}[htb]
	\caption{\label{state_exemplo}Exemplo de State}
	\begin{center}
	    \includegraphics[scale=0.5]{5_padroes-contexto-funcional/5.3_comportamentais/5.3.08_state/state_exemplo.png}
	\end{center}
\end{figure}

\begin{lstlisting}[caption={State Orientação a Objetos},label=oostate]

class TCPConnection(var state : TCPState) {
  def Open(): Unit = state.Open()
  def Close(): Unit = state.Close()
  def Acknowledge(): Unit = state.Acknowledge()
}

trait TCPState {
  def Open()
  def Close()
  def Acknowledge()
}

class TCPEstabilished extends TCPState {
  def Open():Unit = {
    //Implementação para conexão estabelecida
  }
  def Close(): Unit = {
    //Implementação para conexão estabelecida
  }
  def Acknowledge(): Unit = {
    //Implementação para conexão estabelecida
  }
}

class TCPListen extends TCPState {
  def Open():Unit = {
    //Implementação para conexão escutando
  }
  def Close(): Unit = {
    //Implementação para conexão escutando
  }
  def Acknowledge(): Unit = {
    //Implementação para conexão escutando
  }
}

class TCPClosed extends TCPState {
  def Open():Unit = {
    //Implementação para conexão fechada
  }
  def Close(): Unit = {
    //Implementação para conexão fechada
  }
  def Acknowledge(): Unit = {
    //Implementação para conexão fechada
  }
}

\end{lstlisting}

\subsection*{Contexto Funcional}

Para que o comportamento de um valor possa 
ser alterado ao alterar seu estado, ele 
pode ser encapsulado dentro de outro valor. 
No código \ref{fpstate}, o tipo TCPState 
é declarado na linha 2, onde armazena 
três funções: uma para a ação \textit{open}, 
uma para a ação \textit{close} e uma para 
a ação \textit{acknowledge}. Da mesma forma, 
as operações Open, Close e Acknowledge, 
definidas em seguida, recebem como 
parâmetro uma tupla do tipo TCPState e 
executam as funções desejadas.

\begin{lstlisting}[caption={State Funcional},label=fpstate]
    
type TCPState = (() => Unit,
                 () => Unit,
                 () => Unit)

def Open(state : TCPState) : Unit = state._1()

def Close(state : TCPState) : Unit = state._2()

def Acknowledge(state : TCPState) : Unit = state._3()
    
\end{lstlisting}

O código \ref{fpstate} demonstra como seriam 
declaradas as tuplas para cada estado visto 
no exemplo orientado a objetos. Dessa forma, 
os valores TCPEstabilished, TCPClosed e 
TCPListen são utilizados para definir que 
tipo de comportamento o programa deverá 
adotar para cada estado possível.

\begin{lstlisting}[caption={State Funcional},label=fpstate]
    
val TCPEstabilished = (
  () => {
    //Operação Open para conexão estabelecida
  },
  () => {
    //Operação Close para conexão estabelecida
  },
  () => {
    //Operação Acknowledge para conexão estabelecida
  }
)

val TCPClosed = (
  () => {
    //Operação Open para conexão fechada
  },
  () => {
    //Operação Close para conexão fechada
  },
  () => {
    //Operação Acknowledge para conexão fechada
  }
)

val TCPListen = (
  () => {
    //Operação Open para conexão escutando
  },
  () => {
    //Operação Close para conexão escutando
  },
  () => {
    //Operação Acknowledge para conexão escutando
  }
)
    
\end{lstlisting}