
% ---
% Capitulo de revisão de literatura
% ---
\chapter{Orientação a Objetos no Contexto Funcional}
% ---

% Conceitos para mapear

Parte dos padrões de projeto que serão 
analisados usam ou dependem de conceitos 
de orientação a objetos como classes ou 
encapsulamento, o que torna necessário 
realizar um mapeamento desses conceitos 
para o paradigma funcional. A intenção 
desse mapeamento não é implementar 
orientação a objetos em uma linguagem 
funcional, mas entender qual é a utilidade 
de cada um desses conceitos e quais 
recursos em programação funcional podem 
oferecer essa mesma utilidade.


% classes e objetos
\section{Classes e Objetos}

Um objeto pode ser definido como uma representação 
do mundo real que possui características e comportamentos, 
enquanto uma classe é uma abstração dessa representação 
que define quais características e comportamentos um objeto 
deve possuir\cite{umlsystems}. Essas características 
e comportamentos são representados em orientação a 
objetos como atributos e métodos, respectivamente. 
O código \ref{ooclass} demonstra uma classe que 
possui os atributos name e age, além dos métodos 
getName, setName, getAge e setAge, que realizam 
operações sobre esses atributos.

\begin{lstlisting}[caption={Classe comum em Orientação a Objetos},label=ooclass]
    
    class Person(var name : String, var age : Int){

        def getName() : String = this.name

        def setName(name : String) : Unit = this.name = name

        def getAge() : Int = this.age

        def setAge(age : Int) : Unit = this.age = age

    }   

\end{lstlisting}

Dessa forma, é necessário definir uma estrutura em 
programação funcional que possua características e 
funções que operam sobre essas características. 
Um recurso da linguagem Scala que pode agrupar 
as características é a case class, uma estrutura de 
dados imutável que pode definir valores nomeados, 
da mesma forma que uma classe\cite{functionalscala}. 
\footnote{As case classes em Scala são um \textit{syntatic 
sugar} para classes imutáveis, portanto estruturas 
semelhantes não serão encontradas em muitas linguagens 
funcionais. Porém, para o propósito desse mapeamento, 
qualquer estrutura de dados imutável que possa guardar 
qualquer quantidade de valores, como uma tupla, possui a 
mesma utilidade.}

Para representar os métodos de uma classe em uma 
linguagem funcional, já que nossa estrutura de dados 
imutável não armazena funções\footnote{Apesar de não 
ser uma abordagem utilizada neste trabalho, é 
possível armazenar funções nessas estruturas.} e já 
que é necessário que nossas funções sejam puras, 
uma abordagem de implementação desses 
métodos é definir funções que recebam 
como parâmetro um valor do tipo definido em nossa 
estrutura de dados imutável. Seguindo esses dois 
princípios, uma versão funcional da classe apresentada 
no código \ref{ooclass} pode ser vista no código \ref{fpclass}.


\begin{lstlisting}[caption={Representação de uma classe no contexto funcional},label=fpclass]
    
    case class Person(name: String, age: Int)

    def getName(person : Person) : String = person.name

    def setName(person : Person, name : String) : Person = 
        person.copy(name = name)

    def getAge(person : Person) : Int = person.age

    def setAge(person : Person, age : Int) : Person =
        person.copy(age = age)

\end{lstlisting}

% encapsulamento
\section{Encapsulamento}

A abordagem da seção anterior implementa 
classes e objetos, porém precisa ser 
reavaliada para que possa levar em consideração 
o encapsulamento. Encapsulamento pode ser definido 
como uma forma de limitar o acesso a um conjunto 
de dados ou comportamentos de um objeto \cite{quarkoo}. 
A motivação para isso pode vir tanto da necessidade 
de concentrar as alterações externas que um objeto 
pode sofrer em apenas um lugar quanto evitar que 
esse objeto assuma um estado que não deveria ser 
representado. 

Com a ideia de imutabilidade, pode-se 
assumir que um valor não será alterado em partes 
diferentes de uma aplicação, mas é possível 
que funções responsáveis por criar ou modificar\footnote{
    Uma função que modifica um valor é entendida 
    como uma função que recebe um valor existente 
    por parâmetro e retorna um novo valor do mesmo 
    tipo.
} 
um valor de um determinado tipo estejam 
espalhadas pela aplicação, facilitando uma 
situação em que um estado que não deveria ser 
representável por esse valor seja criado. 
Dessa forma, implementar alguma forma de 
encapsulamento ainda é importante no 
contexto funcional.

Existe mais de uma abordagem que torna 
possível implementar o encapsulamento em 
linguagens funcionais, entre elas o uso 
de closures\cite{classlessjs} ou de 
GADTs - \textit{Generalized Algebraic 
Data Types}\cite{existentialhaskell}. 
Porém, a abordagem utilizada neste 
trabalho levará em consideração os 
módulos do sistema ML, já que eles 
possibilitam esconder informações, 
o que será utilizado para esconder a 
forma como nossos tipos são criados 
ou modificados\cite{mlmodules}.


% interfaces
\section{Interfaces}

[Explicação do que é uma interface aqui]

Existe mais de uma alternativa para as interfaces 
e elas dependem da situação na qual a interface é 
utilizada. Considerando o código \ref{oopinterface1}, 
a interface é necessária para garantir que as 
classes InterfaceUserA e InterfaceUserB possuam 
a operação operation, que recebe como parâmetro 
um valor do tipo inteiro e retorna outro valor 
inteiro.

% Exemplo 1 de Interfaces

\begin{lstlisting}[caption={Interfaces em Orientação a Objetos},label=oopinterface1]
    
    trait InterfaceUser {
        def operation(x : Int) : Int
    }

    class InterfaceUserA extends InterfaceUser {
        def operation(x : Int) : Int = x + 1
    }

    class InterfaceUserB extends InterfaceUser {
        def operation(x : Int) : Int = 2*x
    }

    def runInterface(x : Int, interfaceUser : InterfaceUser) : Int {
        return interfaceUser.operation(x)
    }

\end{lstlisting}

Utilizando funções de alta ordem e levando em 
consideração que as funções que representam nossos 
métodos não estão encapsulados em classes e 
não dependem de atributos, podemos substituir o 
objeto sendo passado por parâmetro na função 
runInterface por uma função qualquer que recebe 
como parâmetro um valor inteiro e retorna outro 
valor inteiro. Essa alternativa pode ser vista 
no código \ref{fpinterface1}.

\begin{lstlisting}[caption={Interfaces em Programação Funcional},label=fpinterface1]
    
    def operation1(x : Int) : Int = x + 1

    def operation(x : Int) : Int = 2*x

    def runInterface(x : Int, operation : (Int => Int)) =
        operation(x)
    
\end{lstlisting}


% Exemplo 2 de interfaces

Outra situação em que interfaces são necessárias 
é quando deseja-se especificar um tipo ao qual 
dois tipos diferentes pertencem em comum. Por 
exemplo, no código \ref{oopinterface2} a função 
makeAnimalSound deve receber apenas objetos 
do tipo Animal, ou seja, que implementem 
a interface Animal.

\begin{lstlisting}[caption={Interfaces em Orientação a Objetos},label=oopinterface2]
    
    trait Animal {
        def makeSound() : Unit
    }

    class Dog {
        var dogSound = "Bark bark!"

        def makeSound() : Unit {
            print(dogSound)
        }
    }

    class Cat {
        var catSound = "Meow!"

        def makeSound() : Unit {
            print(catSound)
        }
    }

    def makeAnimalSpeak(animal : Animal) {
        animal.makeSound()
    }

\end{lstlisting}

Linguagens de programação funcionais podem 
recorrer às \textit{typeclasses}\footnote{
    No caso de Scala, elas recebem o nome trait, 
    o mesmo utilizado para declarar interfaces.
}, que definem um tipo em comum para tipos 
diferentes. Esse recurso pode ser acompanhado 
de mais funcionalidades, como exigir que seus 
membros implementem certas operações - o que 
o torna mais semelhante ainda a uma interface - 
porém, esse recurso não será utilizado neste 
trabalho. O código \ref{fpinterface2} demonstra 
seu uso.


\begin{lstlisting}[caption={Interfaces em Programação Funcional},label=fpinterface2]
    
    trait Animal
    case class Dog(val dogSound = "Bark bark!") extends Animal
    def makeDogSound(dog : Dog) : Unit = print(dog.dogSound)
    
    case class Cat(val catSound = "Meow!") extends Animal
    def makeCatSound(cat : Cat) : Unit = print(cat.catSound)

    def makeAnimalSpeak(animal : Animal, soundOperation : (Animal => Unit)) =
        soundOperation()
    
    makeAnimalSpeak(dog, makeDogSound)
    makeAnimalSpeak(cat, makeCatSound)

\end{lstlisting}


% herança
%\section{Herança}