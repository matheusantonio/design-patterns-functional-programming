
% ---
% Capitulo de revisão de literatura
% ---
\chapter{Orientação a Objetos no Contexto Funcional}
% ---

% Conceitos para mapear

Parte dos padrões de projeto que serão 
analisados usam ou dependem de conceitos 
de orientação a objetos como classes ou 
encapsulamento, logo é necessário 
realizar um mapeamento desses conceitos 
para o paradigma funcional. A intenção 
desse mapeamento não é implementar 
orientação a objetos em uma linguagem 
funcional, mas entender qual é a utilidade 
de cada um desses conceitos e quais 
recursos em programação funcional podem 
oferecer essa mesma utilidade.


% classes e objetos
\section{Classes e Objetos}

Um objeto pode ser definido como uma representação 
do mundo real que possui características e comportamentos, 
enquanto uma classe é uma abstração dessa representação, 
que define quais características e comportamentos um objeto 
deve possuir\cite{umlsystems}. Essas características 
e comportamentos são representados, em orientação a 
objetos, como atributos e métodos, respectivamente. 
O código \ref{ooclass} demonstra uma classe que 
possui os atributos name e age, além dos métodos 
getName, setName, getAge e setAge, que realizam 
operações sobre esses atributos.

\begin{lstlisting}[caption={Classe comum em Orientação a Objetos},label=ooclass]
    
    class Person(var name : String, var age : Int){

        def getName() : String = this.name

        def setName(name : String) : Unit = this.name = name

        def getAge() : Int = this.age

        def setAge(age : Int) : Unit = this.age = age

    }   

\end{lstlisting}

Dessa forma, é necessário definir uma estrutura em 
programação funcional que possua características e 
funções que operam sobre essas características. 
Um recurso da linguagem Scala que pode representar 
as características é a case class, uma estrutura de 
dados imutável que pode definir valores nomeados, 
da mesma forma que uma classe\cite{functionalscala}. 
\footnote{As case classes em Scala são um \textit{syntatic 
sugar} para classes imutáveis, portanto, estruturas 
semelhantes não serão encontradas em muitas linguagens 
funcionais. Porém, para o propósito desse mapeamento, 
qualquer estrutura de dados imutável que possa guardar 
qualquer quantidade de valores, como uma tupla, possui a 
mesma utilidade.}

Para representar os métodos de uma classe em uma 
linguagem funcional, já que nossa estrutura de dados 
imutável não armazena funções\footnote{Apesar de não 
ser uma abordagem utilizada neste trabalho, é 
possível armazenar funções nessas estruturas.} e já 
que é necessário seguir o princípio de funções puras, 
onde uma função opera apenas sobre os parâmetros 
fornecidos, uma abordagem de implementar esses 
métodos é simplesmente definir funções que recebam 
como parâmetro um valor do tipo definido em nossa 
estrutura de dados imutável. Seguindo esses dois 
princípios, uma versão funcional da classe apresentada 
no código \ref{ooclass} pode ser vista no código \ref{fpclass}.


\begin{lstlisting}[caption={Representação de uma classe no contexto funcional},label=fpclass]
    
    case class Person(name: String, age: Int)

    def getName(person : Person) : String = person.name

    def setName(person : Person, name : String) : Person = 
        person.copy(name = name)

    def getAge(person : Person) : Int = person.age

    def setAge(person : Person, age : Int) : Person =
        person.copy(age = age)

\end{lstlisting}

% encapsulamento
\section{Encapsulamento}


% interfaces



% herança


