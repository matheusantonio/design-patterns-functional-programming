
% ---
% Capitulo de revisão de literatura
% ---
\chapter{Orientação a Objetos no Contexto Funcional}
% ---

% Conceitos para mapear

Parte dos padrões de projeto que serão 
analisados usam ou dependem de conceitos 
de orientação a objetos como classes ou 
encapsulamento, o que torna necessário 
realizar um mapeamento desses conceitos 
para o paradigma funcional. A intenção 
desse mapeamento não é implementar 
orientação a objetos em uma linguagem 
funcional, mas entender qual é a utilidade 
de cada um desses conceitos e quais 
recursos em programação funcional podem 
oferecer essa mesma utilidade. Isso também 
significa que o mapeamento não será seguido 
de forma rigorosa, ou seja, um padrão 
cuja estrutura possui um objeto, por 
exemplo, não necessariamente terá a 
implementação desse objeto como será 
demonstrada em seguida refletida 
na implementação funcional. Esse 
mapeamento também deve ser usado como 
referência para entender como a 
implementação funcional pode se encaixar 
no contexto dos exemplos utilizados 
para explicar os padrões. 


% classes e objetos
\section{Classes e Objetos}

Um objeto pode ser definido como uma representação 
do mundo real que possui características e comportamentos, 
enquanto uma classe é uma abstração dessa representação 
que define quais características e comportamentos um objeto 
deve possuir\cite{umlsystems}. Essas características 
e comportamentos são representados em orientação a 
objetos como atributos e métodos, respectivamente. 
O código \ref{ooclass} demonstra uma classe que 
possui os atributos name e age, além dos métodos 
getName, setName, getAge e setAge, que realizam 
operações sobre esses atributos.

\begin{lstlisting}[caption={Classe comum em Orientação a Objetos},label=ooclass]
    
    class Person(var name : String, var age : Int){

        def getName() : String = this.name

        def setName(name : String) : Unit = this.name = name

        def getAge() : Int = this.age

        def setAge(age : Int) : Unit = this.age = age

    }   

\end{lstlisting}

Dessa forma, é necessário definir uma estrutura em 
programação funcional que possua características e 
funções que operam sobre essas características. 
Para agrupar características pode ser utilizada uma 
tupla, uma estrutura que armazena uma quantidade 
fixa de valores com tipos predefinidos\cite{tuplesscala}. 
Como as tuplas não podem ser modificadas, elas 
respeitam o conceito de imutabilidade das 
linguagens funcionais.

Para representar os métodos de uma classe em uma 
linguagem funcional, já que nossa estrutura de dados 
imutável não armazenará funções\footnote{Apesar de não 
ser uma abordagem utilizada neste trabalho, é 
possível armazenar funções nessas estruturas.} e já 
que é necessário que nossas funções sejam puras, 
uma abordagem de implementação desses 
métodos é definir funções que recebam 
como parâmetro um valor do tipo definido em nossa 
estrutura de dados imutável. Seguindo esses dois 
princípios, uma versão funcional da classe apresentada 
no código \ref{ooclass} pode ser vista no código \ref{fpclass}.


\begin{lstlisting}[caption={Representação de uma classe no contexto funcional},label=fpclass]
    
    type Person = (String, Int)

    def getName(person : Person) : String = person._1 

    def setName(person : Person, name : String) : Person = 
        (name, person._2)

    def getAge(person : Person) : Int = person._2

    def setAge(person : Person, age : Int) : Person =
        (person._1, age)

\end{lstlisting}

%associação
\section{Associação, Agregação e Composição}

Uma associação pode ser definida como uma 
conexão entre as classes que indica algum 
relacionamento entre elas\cite{Sommerville10}. 
O código \ref{ooassociation} demonstra uma 
associação entre as classes City e State, onde 
a classe State possui uma coleção de atributos 
do tipo City. Para que haja uma associação 
entre duas classes, basta que pelo menos 
uma delas tenha em seus atributos uma 
referência à outra.

\begin{lstlisting}[caption={Exemplo de associação entre classes},label=ooassociation]
    
    class City(var name : String){

        def getName() : String = this.name;
        def setName(name : String) : Unit {
            this.name = name;
        }
    }

    class State(var name : String, var cities : List[City]){

        def getName() : String = this.name;
        def setName(name : String) : Unit {
            this.name = name;
        }
        def getCities() : List[City] = this.cities;
        def addCity(city : City) : Unit {
            this.cities = this.cities :+ city;
        }
    }

\end{lstlisting}

Como foi visto anteriormente, os atributos 
podem ser representados por valores salvos 
dentro de uma tupla associada a um tipo. 
Portanto, uma associação dentro do contexto 
funcional pode ser implementada armazenando 
um valor de um tipo A entre os valores da tupla 
de um tipo B. O código \ref{fpassociation}.

\begin{lstlisting}[caption={Exemplo de associação no contexto funcional},label=fpassociation]
    
    type City = (String)
    
    def getName(city : City) : String = city._1;
    def setName(city : City, name : String) : City = (name)

    type State = (String, City)
    
    def getName(state : State) : String = state._1;
    def setName(state : State, name : String) : State = (name, state._2)
    
    def getCities(state : State) : List[City] = state._2;
    def addCity(state : State, city : City) : State =
        (state._1, state._2 :+ city)

\end{lstlisting}

% encapsulamento
\section{Encapsulamento}

A abordagem da seção anterior implementa 
classes e objetos, porém precisa ser 
reavaliada para que possa levar em consideração 
o encapsulamento. Encapsulamento pode ser definido 
como uma forma de limitar o acesso a um conjunto 
de dados ou comportamentos de um objeto \cite{quarkoo}. 
A motivação para isso pode vir tanto da necessidade 
de concentrar as alterações externas que um objeto 
pode sofrer em apenas um lugar quanto evitar que 
esse objeto assuma um estado que não deveria ser 
representado. 

Com a ideia de imutabilidade, pode-se 
assumir que um valor não será alterado em partes 
diferentes de uma aplicação, mas é possível 
que funções responsáveis por criar ou modificar\footnote{
    Uma função que modifica um valor é entendida 
    como uma função que recebe um valor existente 
    por parâmetro e retorna um novo valor do mesmo 
    tipo.
} 
um valor de um determinado tipo estejam 
espalhadas pela aplicação, facilitando uma 
situação em que um estado que não deveria ser 
representável por esse valor seja criado. 
Dessa forma, implementar alguma forma de 
encapsulamento ainda é importante no 
contexto funcional.

Existe mais de uma abordagem que torna 
possível implementar o encapsulamento em 
linguagens funcionais, o uso de GADTs - 
\textit{Generalized Algebraic 
Data Types}\cite{existentialhaskell} é uma 
delas. Closures também podem 
ser utilizadas ao armazenar valores de 
atributos enquanto retorna as funções 
necessárias para acessá-los ou modificá-los. 
Um exemplo equivalente ao do código \ref{fpclass} 
pode ser visto no código \ref{fpclosure}, 
implementado utilizando a linguagem funcional Clojure. \cite{classlessjs}

\begin{lstlisting}[caption={Representação de uma classe com closures},label=fpclosure]
    
    (defn person [name age]
        {:getName name
         :setName (fn [_name] (person _name age))
         :getAge age
         :setAge (fn [_age] (person name _age))})

\end{lstlisting}

Apesar de não ser um conceito de programação 
funcional, também é possível aproveitar a ideia 
de modularização para esconder detalhes de 
implementação \cite{mlmodules}. Por exemplo, o 
código \ref{modulesencap}, implementado em 
Haskell, mostra o tipo Person com um construtor 
P. Enquanto Person é exportado para fora do 
módulo P não é, tornando impossível para qualquer 
função que acesse esse módulo criar algo do tipo 
Person. Dessa forma, apenas a função newPerson 
pode por criar novos valores do tipo 
Person. Funções implementadas dentro do módulo 
também podem deixar de ser exportadas, o que 
as tornaria semelhantes a métodos privados 
de uma classe.

\begin{lstlisting}[caption={Módulos como forma de encapsulamento},label=modulesencap]
    
    module Person (Person, getName, setName, getAge, setAge) where

    data Person = P (String, Int)

    newPerson :: String -> Int -> Person
    newPerson name age = P (name, age)

    getName :: Person -> String
    getName (P (name, _)) = name

    setName :: Person -> String -> Person
    setName (P (_, age)) name = P (name, age)

    getAge :: Person -> Int
    getAge (P (_, age)) = age

    setAge :: Person -> Int -> Person
    setAge (P (name, _)) age = P (name, age)

\end{lstlisting}

Todas essas abordagens são válidas para a 
implementação do encapsulamento, sendo a 
linguagem utilizada um fator mais decisivo 
do que a abordagem em si. Por exemplo, é 
mais simples implementar a abordagem de closures 
em Clojure por ela ser dinamicamente tipada, 
permitindo que um dicionário sem estrutura 
definida seja retornado. Linguagens que exigem 
uma definição mais estrita do tipo de retorno 
de uma função podem dificultar tanto a 
implementação dessas funções quanto seu uso 
no resto do programa.

Sendo o objetivo dessa seção demostrar que 
o encapsulamento pode ser implementado e 
não definir como implementá-lo, 
a abordagem utilizada para o encapsulamento 
durante a análise dos padrões será 
omitida, a menos que ela seja relevante para 
sua implementação. Essa omissão 
também tem como objetivo facilitar o entendimento 
da abordagem funcional que será utilizada nos padrões.

% interfaces
\section{Interfaces}

Uma interface pode ser entendida como um contrato 
entre uma classe e o mundo externo, indicando que 
uma classe que implementa uma interface também 
implementará as operações definidas 
pela mesma\cite{oracleooconcepts}. 
Como na programação funcional 
as características e comportamentos são separados, 
a implementação de uma interface pode variar de acordo  
com o objetivo desejado.

Um exemplo do uso de interfaces é demonstrado no código 
\ref{oopinterface1}, 
onde a interface é necessária para garantir que as 
classes InterfaceUserA e InterfaceUserB implementem 
a operação operation, que recebe como parâmetro 
um valor do tipo inteiro e retorna outro valor 
inteiro.

% Exemplo 1 de Interfaces

\begin{lstlisting}[caption={Interfaces em Orientação a Objetos},label=oopinterface1]
    
    trait InterfaceUser {
        def operation(x : Int) : Int
    }

    class InterfaceUserA extends InterfaceUser {
        def operation(x : Int) : Int = x + 1
    }

    class InterfaceUserB extends InterfaceUser {
        def operation(x : Int) : Int = 2*x
    }

    def runInterface(x : Int, interfaceUser : InterfaceUser) : Int {
        return interfaceUser.operation(x)
    }

\end{lstlisting}

Utilizando funções de alta ordem e levando em 
consideração que as funções que representam nossos 
métodos não estão encapsulados em classes e 
não dependem de atributos, é possível substituir o 
objeto sendo passado por parâmetro na função 
runInterface por uma função qualquer que recebe 
como parâmetro um valor inteiro e retorna outro 
valor inteiro. Essa alternativa pode ser vista 
no código \ref{fpinterface1}.

\begin{lstlisting}[caption={Interfaces em Programação Funcional},label=fpinterface1]
    
    def operation1(x : Int) : Int = x + 1

    def operation(x : Int) : Int = 2*x

    def runInterface(x : Int, operation : (Int => Int)) =
        operation(x)
    
\end{lstlisting}



% herança
\section{Herança}

Quando é desejado que uma classe seja incluída ou 
utilizada como base para a criação de outra classe, 
usa-se a herança\cite{quarkoo}. Desas forma, é 
possível criar implementações mais específicas 
de classes já existentes e reaproveitar o código. 
O exemplo \ref{ooinheritance} demonstra 
o uso da herança entre as classes Animal e Dog. 
Ao invés de reimplementar os métodos da classe 
Animal, a classe Dog usa herança para reaproveitá-los. 

\begin{lstlisting}[caption={Herança em Orientação a Objetos},label=ooinheritance]
    
    class Animal(var name : String) {
        def getName() : String = name
        
        def eat() : String {
            return "Meu nome é " + name + " e eu posso comer";
        }
    }

    class Dog extends Animal {
        
        def Dog(name : String) {
            super(name);
        }

        def bark() : String {
            return "Bark! Meu nome é " + super.getName();
        }

        def eat() : String {
            return super.eat() + "\nEu como comida de cachorro";
        }
    }

\end{lstlisting}

No contexto funcional, um comportamento semelhante 
pode ser alcançado através da composição. Um tipo A 
que deseja herdar as funcionalidades de um tipo B 
deve possuir uma instância desse mesmo tipo em seus 
atributos. Para os métodos do tipo A, basta que as 
funções do tipo B sejam compostas das funções 
necessárias do tipo A. O código \ref{fpinheritance} 
demonstra o exemplo anterior, onde um tipo Animal 
armazena um valor String que representa o nome 
enquanto o tipo Dog armazena um valor Animal. 
As funções bark e eat que recebem como parâmetro 
um valor do tipo Dog reutilizam as funções getName 
e eat que recebem como parâmetro um valor do tipo 
Animal. Nesse exemplo, o tipo Animal representa 
uma classe pai e o tipo Dog uma class filha.

\begin{lstlisting}[caption={Herança em Programação Funcional},label=fpinheritance]
    
    type Animal = (String)

    def getName(animal : Animal) : String = animal._1;
    def eat(animal : Animal) : String = 
        "Meu nome é " + getName(animal) + " e eu posso comer"

    type Dog = (Animal)

    def getAnimal(dog : Dog) : Animal = dog._1;
    def bark(dog : Dog) : String = 
        "Bark! Meu nome é " + getName(getAnimal(dog))
    def eat(dog : Dog) : String = 
        eat(getAnimal(dog)) + "\nEu como comida de cachorro";

\end{lstlisting}

É possível perceber que a implementação da herança 
assemelha-se à implementação de uma associação. 
Esses dois relacionamentos são diferentes, pois a 
herança trata-se de um relacionamento entre 
classes enquanto a associação é um relacionamento 
entre objetos\cite{umlsystems}. Foi possível 
obervar que essa implementação cumpre o objetivo 
da herança - favorecer o reúso - e como os valores 
no contexto funcional são imutáveis, não é possível 
que o valor que representa a classe pai seja 
modificado externamente.

Essa implementação apresenta uma desvantagem: 
qualquer função do tipo que representa 
a classe pai, que poderia ser acessada 
diretamente a partir da classe filho 
no contexto orientado a objetos, 
necessitaria de uma função intermediária 
do tipo que representa a classe filha 
para acessá-la. Para contornar esse 
problema, basta implementar uma função 
de acesso que retorne o valor do tipo 
da classe pai, como a função getAnimal 
no código \ref{fpinheritance}. Porém, isso 
faz com que, do ponto de vista orientado a 
objetos, a implementação se torne uma 
associação e não uma herança. 