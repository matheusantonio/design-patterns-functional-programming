
% ---
% Capitulo de revisão de literatura
% ---
\chapter{Orientação a Objetos no Contexto Funcional}
% ---

% Conceitos para mapear

Parte dos padrões de projeto que serão 
analisados usam ou dependem de conceitos 
de orientação a objetos como classes ou 
encapsulamento, o que torna necessário 
realizar um mapeamento desses conceitos 
para o paradigma funcional. A intenção 
desse mapeamento não é implementar 
orientação a objetos em uma linguagem 
funcional, mas entender qual é a utilidade 
de cada um desses conceitos e quais 
recursos em programação funcional podem 
oferecer essa mesma utilidade.


% classes e objetos
\section{Classes e Objetos}

Um objeto pode ser definido como uma representação 
do mundo real que possui características e comportamentos, 
enquanto uma classe é uma abstração dessa representação 
que define quais características e comportamentos um objeto 
deve possuir\cite{umlsystems}. Essas características 
e comportamentos são representados em orientação a 
objetos como atributos e métodos, respectivamente. 
O código \ref{ooclass} demonstra uma classe que 
possui os atributos name e age, além dos métodos 
getName, setName, getAge e setAge, que realizam 
operações sobre esses atributos.

\begin{lstlisting}[caption={Classe comum em Orientação a Objetos},label=ooclass]
    
    class Person(var name : String, var age : Int){

        def getName() : String = this.name

        def setName(name : String) : Unit = this.name = name

        def getAge() : Int = this.age

        def setAge(age : Int) : Unit = this.age = age

    }   

\end{lstlisting}

Dessa forma, é necessário definir uma estrutura em 
programação funcional que possua características e 
funções que operam sobre essas características. 
Um recurso da linguagem Scala que pode agrupar 
as características é a case class, uma estrutura de 
dados imutável que pode definir valores nomeados, 
da mesma forma que uma classe\cite{functionalscala}. 
\footnote{As case classes em Scala são um \textit{syntatic 
sugar} para classes imutáveis, portanto estruturas 
semelhantes não serão encontradas em muitas linguagens 
funcionais. Porém, para o propósito desse mapeamento, 
qualquer estrutura de dados imutável que possa guardar 
qualquer quantidade de valores, como uma tupla, possui a 
mesma utilidade.}

Para representar os métodos de uma classe em uma 
linguagem funcional, já que nossa estrutura de dados 
imutável não armazena funções\footnote{Apesar de não 
ser uma abordagem utilizada neste trabalho, é 
possível armazenar funções nessas estruturas.} e já 
que é necessário que nossas funções sejam puras, 
uma abordagem de implementação desses 
métodos é definir funções que recebam 
como parâmetro um valor do tipo definido em nossa 
estrutura de dados imutável. Seguindo esses dois 
princípios, uma versão funcional da classe apresentada 
no código \ref{ooclass} pode ser vista no código \ref{fpclass}.


\begin{lstlisting}[caption={Representação de uma classe no contexto funcional},label=fpclass]
    
    case class Person(name: String, age: Int)

    def getName(person : Person) : String = person.name

    def setName(person : Person, name : String) : Person = 
        person.copy(name = name)

    def getAge(person : Person) : Int = person.age

    def setAge(person : Person, age : Int) : Person =
        person.copy(age = age)

\end{lstlisting}

% encapsulamento
\section{Encapsulamento}

A abordagem da seção anterior implementa 
classes e objetos, porém precisa ser 
reavaliada para que possa levar em consideração 
o encapsulamento. Encapsulamento pode ser definido 
como uma forma de limitar o acesso a um conjunto 
de dados ou comportamentos de um objeto \cite{quarkoo}. 
A motivação para isso pode vir tanto da necessidade 
de concentrar as alterações externas que um objeto 
pode sofrer em apenas um lugar quanto evitar que 
esse objeto assuma um estado que não deveria ser 
representado. 

Com a ideia de imutabilidade, pode-se 
assumir que um valor não será alterado em partes 
diferentes de uma aplicação, mas é possível 
que funções responsáveis por criar ou modificar\footnote{
    Uma função que modifica um valor é entendida 
    como uma função que recebe um valor existente 
    por parâmetro e retorna um novo valor do mesmo 
    tipo.
} 
um valor de um determinado tipo estejam 
espalhadas pela aplicação, facilitando uma 
situação em que um estado que não deveria ser 
representável por esse valor seja criado. 
Dessa forma, implementar alguma forma de 
encapsulamento ainda é importante no 
contexto funcional.

Existe mais de uma abordagem que torna 
possível implementar o encapsulamento em 
linguagens funcionais, entre elas o uso 
de closures\cite{classlessjs} ou de 
GADTs - \textit{Generalized Algebraic 
Data Types}\cite{existentialhaskell}. 
Porém, a abordagem utilizada neste 
trabalho levará em consideração os 
módulos do sistema ML, já que eles 
possibilitam esconder informações, 
o que será utilizado para esconder a 
forma como nossos tipos são criados 
ou modificados\cite{mlmodules}.


% interfaces
\section{Interfaces e Polimorfismo}

[Explicação do que é uma interface aqui]

Existe mais de uma alternativa para as interfaces 
e elas dependem da situação na qual a interface é 
utilizada. Considerando o código \ref{oopinterface1}, 
a interface 

% Exemplo 1 de Interfaces

\begin{lstlisting}[caption={Interfaces em Orientação a Objetos},label=oopinterface1]
    
    trait InterfaceUser {
        def operation(x : Int) : Int
    }

    class InterfaceUserA extends InterfaceUser {
        def operation(x : Int) : Int = x + 1
    }

    class InterfaceUserB extends InterfaceUser {
        def operation(x : Int) : Int = 2*x
    }

    def runInterface(x : Int, interfaceUser : InterfaceUser) : Int {
        return interfaceUser.operation(x)
    }

\end{lstlisting}


\begin{lstlisting}[caption={Interfaces em Programação Funcional},label=fpinterface1]
    
    def operation1(x : Int) : Int = x + 1

    def operation(x : Int) : Int = 2*x

    def runInterface(x : Int, operation : (Int => Int)) =
        operation(x)
    

\end{lstlisting}







% Exemplo 2 de interfaces

\begin{lstlisting}[caption={Interfaces em Orientação a Objetos},label=oopinterface2]
    
    trait Animal {
        def makeSound() : Unit
    }

    class Dog {

        var dogSound = "Bark bark!"

        def makeSound() : Unit {
            print(dogSound)
        }
    }

    class Cat {

        var catSound = "Meow!"

        def makeSound() : Unit {
            print(catSound)
        }
    }

    def makeAnimalSpeak(animal : Animal) {
        animal.makeSound()
    }

\end{lstlisting}


\begin{lstlisting}[caption={Interfaces em Programação Funcional},label=fpinterface2]
    
    sealed trait Animal
    case class Dog(val dogSound = "Bark bark!") extends Animal
    case class Cat(val catSound = "Meow!") extends Animal

    def makeAnimalSpeak(soundOperation : (Animal => Unit)) =
        soundOperation()
    

\end{lstlisting}









\begin{lstlisting}[caption={},label=]
    
    

\end{lstlisting}





% herança
%\section{Herança}


