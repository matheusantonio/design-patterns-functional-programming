
% ---
% Capitulo de revisão de literatura
% ---
\chapter{Orientação a Objetos no Contexto Funcional}
% ---

% Conceitos para mapear

Parte dos padrões de projeto que serão 
analisados usam ou dependem de conceitos 
de orientação a objetos como classes ou 
encapsulamento, o que torna necessário 
realizar um mapeamento desses conceitos 
para o paradigma funcional. A intenção 
desse mapeamento não é implementar 
orientação a objetos em uma linguagem 
funcional, mas entender qual é a utilidade 
de cada um desses conceitos e quais 
recursos em programação funcional podem 
oferecer essa mesma utilidade.


% classes e objetos
\section{Classes e Objetos}

Um objeto pode ser definido como uma representação 
do mundo real que possui características e comportamentos, 
enquanto uma classe é uma abstração dessa representação 
que define quais características e comportamentos um objeto 
deve possuir\cite{umlsystems}. Essas características 
e comportamentos são representados em orientação a 
objetos como atributos e métodos, respectivamente. 
O código \ref{ooclass} demonstra uma classe que 
possui os atributos name e age, além dos métodos 
getName, setName, getAge e setAge, que realizam 
operações sobre esses atributos.

\begin{lstlisting}[caption={Classe comum em Orientação a Objetos},label=ooclass]
    
    class Person(var name : String, var age : Int){

        def getName() : String = this.name

        def setName(name : String) : Unit = this.name = name

        def getAge() : Int = this.age

        def setAge(age : Int) : Unit = this.age = age

    }   

\end{lstlisting}

Dessa forma, é necessário definir uma estrutura em 
programação funcional que possua características e 
funções que operam sobre essas características. 
Para agrupar características pode ser utilizada uma 
tupla, uma estrutura que armazena uma quantidade 
fixa de valores com tipos predefinidos\cite{tuplesscala}. 
Como as tuplas não podem ser modificadas, elas 
respeitam o conceito de imutabilidade das 
linguagens funcionais.

Para representar os métodos de uma classe em uma 
linguagem funcional, já que nossa estrutura de dados 
imutável não armazenará funções\footnote{Apesar de não 
ser uma abordagem utilizada neste trabalho, é 
possível armazenar funções nessas estruturas.} e já 
que é necessário que nossas funções sejam puras, 
uma abordagem de implementação desses 
métodos é definir funções que recebam 
como parâmetro um valor do tipo definido em nossa 
estrutura de dados imutável. Seguindo esses dois 
princípios, uma versão funcional da classe apresentada 
no código \ref{ooclass} pode ser vista no código \ref{fpclass}.


\begin{lstlisting}[caption={Representação de uma classe no contexto funcional},label=fpclass]
    
    type Person = (String, Int)

    def getName(person : Person) : String = person._1 

    def setName(person : Person, name : String) : Person = 
        (name, person._2)

    def getAge(person : Person) : Int = person._2

    def setAge(person : Person, age : Int) : Person =
        (person._1, age)

\end{lstlisting}

% encapsulamento
\section{Encapsulamento}

A abordagem da seção anterior implementa 
classes e objetos, porém precisa ser 
reavaliada para que possa levar em consideração 
o encapsulamento. Encapsulamento pode ser definido 
como uma forma de limitar o acesso a um conjunto 
de dados ou comportamentos de um objeto \cite{quarkoo}. 
A motivação para isso pode vir tanto da necessidade 
de concentrar as alterações externas que um objeto 
pode sofrer em apenas um lugar quanto evitar que 
esse objeto assuma um estado que não deveria ser 
representado. 

Com a ideia de imutabilidade, pode-se 
assumir que um valor não será alterado em partes 
diferentes de uma aplicação, mas é possível 
que funções responsáveis por criar ou modificar\footnote{
    Uma função que modifica um valor é entendida 
    como uma função que recebe um valor existente 
    por parâmetro e retorna um novo valor do mesmo 
    tipo.
} 
um valor de um determinado tipo estejam 
espalhadas pela aplicação, facilitando uma 
situação em que um estado que não deveria ser 
representável por esse valor seja criado. 
Dessa forma, implementar alguma forma de 
encapsulamento ainda é importante no 
contexto funcional.

Existe mais de uma abordagem que torna 
possível implementar o encapsulamento em 
linguagens funcionais, o uso de GADTs - 
\textit{Generalized Algebraic 
Data Types}\cite{existentialhaskell} é uma 
delas. Closures também podem 
ser utilizadas ao armazenar valores de 
atributos enquanto retorna as funções 
necessárias para acessá-los ou modificá-los. 
Um exemplo equivalente ao do código \ref{fpclass} 
pode ser visto no código \ref{fpclosure}, 
implementado utilizando a linguagem funcional Clojure. \cite{classlessjs}

\begin{lstlisting}[caption={Representação de uma classe com closures},label=fpclosure]
    
    (defn person [name age]
        {:getName name
         :setName (fn [_name] (person _name age))
         :getAge age
         :setAge (fn [_age] (person name _age))})

\end{lstlisting}

Apesar de não ser um conceito de programação 
funcional, também é possível aproveitar a ideia 
de modularização para esconder detalhes de 
implementação \cite{mlmodules}. Por exemplo, o 
código \ref{modulesencap}, implementado em 
Haskell, mostra o tipo Person com um construtor 
P. Enquanto Person é exportado para fora do 
módulo P não é, tornando impossível para qualquer 
função que acesse esse módulo criar algo do tipo 
Person. Dessa forma, apenas a função newPerson 
pode por criar novos valores do tipo 
Person. Funções implementadas dentro do módulo 
também podem deixar de ser exportadas, o que 
as tornaria semelhantes a métodos privados 
de uma classe.

\begin{lstlisting}[caption={Módulos como forma de encapsulamento},label=modulesencap]
    
    module Person (Person, getName, setName, getAge, setAge) where

    data Person = P (String, Int)

    newPerson :: String -> Int -> Person
    newPerson name age = P (name, age)

    getName :: Person -> String
    getName (P (name, _)) = name

    setName :: Person -> String -> Person
    setName (P (_, age)) name = P (name, age)

    getAge :: Person -> Int
    getAge (P (_, age)) = age

    setAge :: Person -> Int -> Person
    setAge (P (name, _)) age = P (name, age)

\end{lstlisting}

Todas essas abordagens são válidas para a 
implementação do encapsulamento, sendo a 
linguagem utilizada um fator mais decisivo 
do que a abordagem em si. Por exemplo, é 
mais simples implementar a abordagem de closures 
em Clojure por ela ser dinamicamente tipada, 
permitindo que um dicionário sem estrutura 
definida seja retornado. Linguagens que exigem 
uma definição mais estrita do tipo de retorno 
de uma função podem dificultar tanto a 
implementação dessas funções quanto seu uso 
no resto do programa.

Sendo o objetivo dessa seção demostrar que 
o encapsulamento pode ser implementado e 
não definir como implementá-lo, 
a abordagem utilizada para o encapsulamento 
durante a análise dos padrões será 
omitida, a menos que ela seja relevante para 
sua implementação. Essa omissão 
também tem como objetivo facilitar o entendimento 
da abordagem funcional que será utilizada nos padrões.

% interfaces
\section{Interfaces}

Uma interface pode ser entendida como um contrato 
entre uma classe e o mundo externo, indicando que 
uma classe que implementa uma interface também 
implementará as operações definidas 
pela mesma\cite{oracleooconcepts}. 
Como na programação funcional 
as características e comportamentos são separados, 
a implementação de uma interface pode variar de acordo  
com o objetivo desejado. Em seguida, serão abordadas 
algumas situações que requerem interfaces e como 
elas poderiam ser implementadas.

% Quando definimos uma interface (trait) e as funções 
% (métodos) que recebem algo do tipo dessa trait como 
% parâmetro, nossa interface é a trait + as funções.
% Portanto, se definimos um tipo, X, como pertencente 
% a essa trait, dizemos que ele é recebível por essas 
% funções e deve se comportar como tal. (verificar 
% outros casos possíveis)

A primeira situação é considerada no código 
\ref{oopinterface1}, 
onde a interface é necessária para garantir que as 
classes InterfaceUserA e InterfaceUserB implementem 
a operação operation, que recebe como parâmetro 
um valor do tipo inteiro e retorna outro valor 
inteiro.

% Exemplo 1 de Interfaces

\begin{lstlisting}[caption={Interfaces em Orientação a Objetos},label=oopinterface1]
    
    trait InterfaceUser {
        def operation(x : Int) : Int
    }

    class InterfaceUserA extends InterfaceUser {
        def operation(x : Int) : Int = x + 1
    }

    class InterfaceUserB extends InterfaceUser {
        def operation(x : Int) : Int = 2*x
    }

    def runInterface(x : Int, interfaceUser : InterfaceUser) : Int {
        return interfaceUser.operation(x)
    }

\end{lstlisting}

Utilizando funções de alta ordem e levando em 
consideração que as funções que representam nossos 
métodos não estão encapsulados em classes e 
não dependem de atributos, podemos substituir o 
objeto sendo passado por parâmetro na função 
runInterface por uma função qualquer que recebe 
como parâmetro um valor inteiro e retorna outro 
valor inteiro. Essa alternativa pode ser vista 
no código \ref{fpinterface1}.

\begin{lstlisting}[caption={Interfaces em Programação Funcional},label=fpinterface1]
    
    def operation1(x : Int) : Int = x + 1

    def operation(x : Int) : Int = 2*x

    def runInterface(x : Int, operation : (Int => Int)) =
        operation(x)
    
\end{lstlisting}


% Exemplo 2 de interfaces

Outra situação em que interfaces são necessárias 
é quando deseja-se especificar um tipo ao qual 
dois tipos diferentes pertencem em comum. Por 
exemplo, no código \ref{oopinterface2} a função 
makeAnimalSound deve receber apenas objetos 
do tipo Animal, ou seja, que implementem 
a interface Animal.

\begin{lstlisting}[caption={Interfaces em Orientação a Objetos},label=oopinterface2]
    
    trait Animal {
        def makeSound() : Unit
    }

    class Dog extends Animal {
        var dogSound = "Bark bark!"

        def makeSound() : Unit {
            print(dogSound)
        }
    }

    class Cat extends Cat {
        var catSound = "Meow!"

        def makeSound() : Unit {
            print(catSound)
        }
    }

    def makeAnimalSpeak(animal : Animal) {
        animal.makeSound()
    }

\end{lstlisting}

Linguagens de programação funcionais podem 
recorrer às \textit{typeclasses}\footnote{
    No caso de Scala, elas recebem o nome trait, 
    o mesmo utilizado para declarar interfaces.
}, que definem um tipo em comum para tipos 
diferentes. Esse recurso pode ser acompanhado 
de mais funcionalidades, como exigir que seus 
membros implementem certas operações - o que 
o torna mais semelhante ainda a uma interface. 
Porém, esse recurso não será utilizado neste 
trabalho. O código \ref{fpinterface2} demonstra 
seu uso.


\begin{lstlisting}[caption={Interfaces em Programação Funcional},label=fpinterface2]
    
    trait Animal
    case class Dog(val dogSound = "Bark bark!") extends Animal
    def makeDogSound(dog : Dog) : Unit = print(dog.dogSound)
    
    case class Cat(val catSound = "Meow!") extends Animal
    def makeCatSound(cat : Cat) : Unit = print(cat.catSound)

    def makeAnimalSpeak(animal : Animal, soundOperation : (Animal => Unit)) =
        soundOperation()
    
    makeAnimalSpeak(dog, makeDogSound)
    makeAnimalSpeak(cat, makeCatSound)

\end{lstlisting}

% Incluir comentário sobre tipagem da linguagem?

% herança
%\section{Herança}
%
%Quando é desejado que uma classe seja 
%utilizada como base para a criação de outra, 
%o mecanismo da herança permite relacioná-las\cite{quarkoo}. 
%Por exemplo, o código \ref{fpinheritance} demonstra 
%o uso da herança entre as classes Product e Book.
%
%\begin{lstlisting}[caption={Herança em Programação Funcional},label=fpinheritance]
%    
%    class Product {
%
%    }
%
%    class Book {
%
%    }
%
%\end{lstlisting}

