% ---
% Apresentação dos Resultados
% ---
\chapter{Resultados}
% ---

Nos capítulos anteriores, foram analisados todos 
vinte e três padrões de projeto \textit{Gang of 
Four}, com o objetivo de extrair o problema 
resolvido pelo padrão e analisar, a partir dos 
conceitos de programação funcional apresentados, 
como uma solução para o mesmo problema poderia ser 
alcançada. Foi possível separar as análises realizadas em 
quatro grandes grupos, com o primeiro sendo 
dividido em três subgrupos: 

\begin{alineas}
    \item Padrões resolvidos por funções de alta ordem
    \begin{alineas}
        \item Funções de alta ordem como alternativa a classes abstratas ou interfaces
        \item Valores que armazenam funções
        \item Funções que armazenam valores em closures
    \end{alineas}
    \item Padrões com soluções alternativas
    \item Padrões sem diferenças relevantes
    \item Padrões que não fazem sentido no contexto funcional
\end{alineas}

Esses grupos estão organizados na tabela 
\ref{resultados}, onde são apresentados os 
padrões pertencentes a cada grupo com a 
quantidade de padrões pertencentes ao grupo. 
Cada grupo será explicado com mais detalhes 
no decorrer do capítulo.

\begin{quadro}[htb]
    \caption{\label{resultados}Agrupamento de análises dos padrões}
    \begin{tabular}{@{}llll@{}}
        \toprule
                                  &                            & Padrões                 & Quantidade         \\ \midrule
        \multirow{14}{*}{Grupo A} & \multirow{7}{*}{A.1} & Factory Method          & \multirow{7}{*}{7} \\
                                  &                            & Builder                 &                    \\
                                  &                            & Adapter                 &                    \\
                                  &                            & Bridge                  &                    \\
                                  &                            & Proxy                   &                    \\
                                  &                            & Strategy                &                    \\
                                  &                            & Template Method         &                    \\ \cmidrule(r){2-4}
                                  & \multirow{3}{*}{A.2} & Abstract Factory        & \multirow{3}{*}{3} \\
                                  &                            & Command                 &                    \\
                                  &                            & State                   &                    \\ \cmidrule(r){2-4}
                                  & \multirow{4}{*}{A.3} & Composite               & \multirow{4}{*}{4} \\
                                  &                            & Decorator               &                    \\
                                  &                            & Chain of Responsibility &                    \\
                                  &                            & Interpreter             &                    \\ \cmidrule(r){1-4}
        \multicolumn{2}{l}{\multirow{3}{*}{Grupo B}}           & Iterator                & \multirow{3}{*}{3} \\
        \multicolumn{2}{l}{}                                   & Observer                &                    \\
        \multicolumn{2}{l}{}                                   & Visitor                 &                    \\ \cmidrule(r){1-4}
        \multicolumn{2}{l}{\multirow{3}{*}{Grupo C}}           & Façade                  & \multirow{3}{*}{3} \\
        \multicolumn{2}{l}{}                                   & Flyweight               &                    \\
        \multicolumn{2}{l}{}                                   & Mediator                &                    \\ \cmidrule(r){1-4}
        \multicolumn{2}{l}{\multirow{3}{*}{Grupo D}}           & Prototype               & \multirow{3}{*}{3} \\ 
        \multicolumn{2}{l}{}                                   & Singleton               &                    \\
        \multicolumn{2}{l}{}                                   & Memento                 &                    \\ \cmidrule(r){1-4} %\cmidrule(l){4-4} 
    \end{tabular}
\end{quadro}

\section{Padrões resolvidos por funções de alta ordem}

Entre as soluções vistas, a que é aplicada na 
maior parte dos padrões é o uso de funções de alta 
ordem como alternativa a interfaces ou classes. 
Um total de catorze dos vinte e três padrões 
se encaixa nessa categoria. Por isso, ainda foi 
possível dividir esses padrões em três  
subcategorias quanto a como as funções de alta 
ordem foram aplicadas. Alguns padrões acabam se 
encaixando em mais de uma das categorias, mas para 
evitar repetições e para simplificar o agrupamento, 
cada padrão será explicado no grupo mais próximo 
da solução proposta. 

% Factory Method, Builder, Adapter, Bridge, 
% Proxy, Strategy, Template Method
\subsection{Funções de alta ordem como alternativa a 
            classes abstratas ou interfaces}

Como foi visto no mapeamento de conceitos orientados 
a objeto para conceitos de programação funcional, 
funções de alta ordem podem servir como alternativas 
para o uso de interfaces. Alguns dos padrões analisados 
baseiam-se no uso de interfaces para definir a assinatura 
de funções que a classe cliente deve receber. De forma 
equivalente, é possível que uma função cliente receba, 
por parâmetro, uma função com a assinatura equivalente 
à da interface. Essa é a abordagem utilizada com os 
padrões Builder, Adapter, Bridge, Proxy e Strategy. 

De forma semelhante, as funções de alta ordem são 
alternativas ao uso de 
classes abstratas, como é o caso dos padrõess 
Factory Method e Template Method. Ambos baseiam-se 
em definir uma operação abstrata que deve ser 
implementada por uma subclasse. Uma alternativa 
a essa implementação é fazer com que as funções 
que dependam dessa operação abstrata a recebam 
por parâmetro.

% Abstract Factory, Command, State
\subsection{Valores que armazenam funções}

Os padrões Abstract Factory, Command e 
State também baseiam-se em passar funções de 
alta ordem como parâmetro para funções clientes. 
Porém, para esses três padrões, as funções 
passadas são relacionadas, ou seja, 
todas as funções de um Strategy pertencem a uma mesma 
estratégia, todas as funções do Abstract Factory criam 
o mesmo tipo de valor e a função de desfazer do 
Command está relacionada à função principal executada. 
Agrupar essas funções em um mesmo valor pode 
contribuir para retirar das funções clientes a 
responsabilidade de garantir que elas possuam 
essa equivalência.

% Composite, Decorator, Chain of Responsibility, Interpreter
\subsection{Funções que armazenam valores em closures}

Algumas implementações basearam-se em definir funções 
que retornam novas funções. Isso é necessário para 
que seja possível configurar as funções retornadas 
com valores recebidos por parâmetro pelas funções 
que as criam. Esse é o comportamento definido pelas 
closures, onde uma determinada função armazena 
um valor do escopo da função que a retornou. 

O padrão Composite define funções para gerar os 
elementos nós e os elementos folha. Dessa forma, 
a partir de uma única função, vários elementos 
folha e nó configurados com valores diferentes 
podem ser gerados.

De forma semelhante, o padrão Decorator define 
funções que podem receber como parâmetro valores 
variados enquanto retorna uma nova função com 
a mesma assinatura da função decorada. 

O padrão Chain of Responsibility aproveita a mesma 
ideia para gerar as funções da cadeia. O tópico e 
a próxima função da cadeia são passadas por parâmetro 
previamente, armazenadas na closure e reaproveitadas 
na função retornada. 

Por fim, o padrão Interpreter apresenta um comportamento 
semelhante ao Composite, definindo funções que retornam 
os elementos terminais e não terminais, permitindo 
inclusive definir funções mais genéricas que recebem 
a função que aplica a regra da gramática por parâmetro.

% Iterator, Observer, Visitor
\section{Padrões com soluções alternativas}

Os padrões Iterator, Observer e Visitor possuem 
implementações alternativas existentes que não 
necessariamente 
seguem à risca a ideia do padrão. No caso do Iterator, 
existe a diferença entre o gerencimaneto por parte 
do cliente e por parte da coleção entre as 
alternativas orientada a objetos e funcional. No 
caso do Observer, o conceito no qual ele se 
baseia - programação reativa - é levado em 
consideração ao substituí-lo pela programação 
reativa funcional. Já o Visitor, apesar de também 
aproveitar-se de funções de alta ordem, na verdade 
é resolvido pelo recurso \textit{pattern matching}, 
que não é um conceito exclusivamente funcional, 
porém costuma ser implementado em linguagens 
funcionais. Nesse caso, o padrão não foi 
resolvido por programação funcional em si, 
mas sim por uma alternativa próxima. 

% Façade, Flyweight, Mediator
\section{Padrões sem diferenças relevantes}

Alguns dos padrões analisados possuem 
uma implementação muito semelhante ou 
equivalente entre os contextos orientados 
a objeto e funcionais, como se a solução 
proposta pelo padrão estivesse apenas 
sendo reutilizada por si só, sem 
recursos adicionais oriundos da programação 
funcional que contribuem para a 
resolução do problema. 

Da mesma forma que o padrão Façade orientado 
a objetos baseia-se no acesso entre as classes, 
a implementação funcional baseia-se no acesso 
entre módulos. Como ambas as ideias são 
análogas, a implementação do padrão na verdade 
não possui mudanças significativas. 
O padrão Flyweight, tanto no 
contexto orientado a objetos quanto no funcional, 
é implementado através de memoização. Já o Mediator 
baseia-se em possuir uma função (ou classe) que 
gerencia as dependências entre valores (ou objetos). 
No caso desses dois padrões, ambos possuem 
pequenas diferenças como consequência de suas 
implementações - por exemplo, não existem os dois 
tipos de Flyweight intrínseco ou extrínseco 
graças à imutabilidade e há a necessidade do 
cliente gerenciar a mudança de estado dos 
\textit{colleagues} no Mediator -, mas a ideia 
por trás da implementação de ambos é análoga 
à versão orientada a objetos.

% Prototype (imutabilidade), Singleton (funções puras), 
% Memento (imutabilidade)
\section{Padrões que não fazem sentido no contexto funcional}

Para alguns padrões, o problema proposto deixa 
de existir graças aos conceitos já implementados 
em linguagens funcionais. No caso dos padrões 
analisados neste trabalho, encaixam-se nessa 
categoria o Singleton, o Prototype e o Memento. 

Como a intenção do padrão Singleton pode 
ser entendida como a definição de uma variável 
global, sua implementação no contexto funcional 
viola o conceito de funções puras e imutabilidade - 
para o caso em que o Singleton armazena algum 
estado compartilhado. Portanto, tentar 
implementá-lo não faz sentido. 

Para o caso do Prototype, como visto anteriormente, 
o uso de estruturas de dados imutáveis trazem um 
gerenciamento mais simples de memória. Não existe 
preocupação quanto a uma referência compartilhada 
para um mesmo valor, já que seu estado não pode ser 
modificado. Dessa forma, não há a necessidade de 
definir uma implementação que compartilhe dados.

Por fim, o padrão Memento, também graças à 
imutabilidade, não precisaria se preocupar quanto 
a expor o estado interno de um valor. Assim, é 
possível gerar \textit{snapshots} apenas copiando 
valores anteriores, sem preocupações adicionais. 

\section{Avaliação dos Resultados}
% É importante descrever quais resultados são mais
% relevantes e como eles contribuem com a área 
% de estudo
%\section{Avaliação}

Como pôde ser visto, a aplicação dos 
conceitos de programação funcional pode 
contribuir para a solução de alguns dos padrões. 
Com o uso de funções de alta ordem, padrões 
que apresentam interfaces com poucas funções, como o 
Template Method, ou muitas funções 
não necessariamente relacionadas, como 
o Builder, poderiam aproveitar-se do 
uso de funções de alta ordem para diminuir a 
quantidade de classes definidas pela 
aplicação. Para os casos em que as funções 
são relacionadas e agrupadas em 
novos valores como no padrão State, 
o comportamento final torna-se semelhante 
ao de uma interface, onde são declarados 
tipos que armazenam funções e criados 
valores que definem quais funções são 
equivalentes àquele tipo. 
O diferencial é que 
é mais simples reaproveitar uma mesma 
função para valores diferentes, já que 
em um contexto orientado a objetos seria 
necessário definir classes abstratas 
para definir um comportamento compartilhado 
por várias classes que implementem uma 
mesma interface.
A última abordagem, usando closures, também 
demonstrou flexibilidade e possibilidade 
de reuso, como visto no padrão Interpreter. 
Além de permitir a criação de novas funções, 
é possível parametrizá-las através de 
outras funções.

O uso de conceitos de programação funcional 
para resolver alguns dos problemas propostos 
pelos padrões não é algo novo, como foi visto 
pelos padrões que já possuíam soluções alternativas 
conhecidas. As funções \textit{map} e \textit{reduce} 
usadas como alternativa para o Iterator já 
são implementadas em diversas linguagens funcionais
\cite{realworldhaskell,wampler2021,braveclojure}, 
enquanto o conceito de programação reativa, 
um tipo de Observer, já é 
utilizado em \textit{frameworks} de  
\textit{single page application}\cite{rxjs}. 
O recurso de \textit{pattern matching} 
utilizado na análise do Visitor também já 
é um conceito conhecido como alternativa 
aos multimétodos\cite{patternmatchingvisitor}.

Em seguida, com os padrões sem diferenças 
relevantes de implementação, pôde ser visto 
que nem todos os padrões utilizam abordagens 
exclusivamente orientadas a objetos. Dessa forma, 
transpô-los para o contexto funcional 
permite que a mesma solução seja reaproveitada. 
Apesar de terem sido apresentadas algumas 
ressalvas, elas não estão diretamente ligadas 
à solução proposta, mas às consequências de 
se utilizá-la, como é o caso do Mediator 
precisar que a função cliente gerencie o 
estado dos \textit{colleagues}. 

Por fim, foi visto o grupo dos padrões 
que não fazem sentido no contexto funcional, 
já que os problemas propostos não existem. 
Esse foi o caso dos padrões Prototype e Memento.
Outro caso desse grupo foi a existência de 
um padrão cuja intenção viola algum conceito da 
programação funcional, o Singleton. 
É relevante informar que o padrão Singleton 
pode ser considerado um antipadrão que poderia 
ser substituído pela injeção de dependência.
\cite{singletonantipattern}. Isso poderia 
ser um indício de que a aplicação de 
conceitos funcionais contribui para 
identificar problemas de \textit{design} de 
\textit{software}, mas como o Singleton 
foi o único dos vinte e três padrões que 
apresentou esse comportamento, faltam 
evidências para considerar essa 
possibilidade.

% Um bom embasamento teórico é fundamental para 
% dar credibilidade aos resultados da pesquisa 
% Portanto, o investigador deve comparar as 
% ideais de outros autores com a descoberta do 
% seu trabalho
%\section{Comparação com a literatura}

% Quando a coleta de dados é representativa, 
% o pesquisador pode fazer generalizações
%\section{Generalização}